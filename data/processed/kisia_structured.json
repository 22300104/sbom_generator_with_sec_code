{
  "vulnerabilities": [
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 1,
      "korean_name": "SQL 삽입",
      "english_type": "SQL_Injection",
      "start_page": 8,
      "end_page": 13,
      "description": "검증되지 않은 외부 입력을 문자열 결합으로 동적 SQL에 포함하면 쿼리 구조가 변조되어 비인가 조회, 수정, 삭제가 가능해진다. 안전 대책은 DB 드라이버가 제공하는 매개변수 바인딩(placeholder) 사용, ORM의 안전한 API 사용, 화이트리스트 기반 입력 검증, 최소권한 DB 계정 적용이다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from django.db import connection\n\ndef update_board(request):\n    name = request.POST.get('name', '')\n    content_id = request.POST.get('content_id', '')\n    # 문자열 결합으로 동적 SQL 구성 → SQLi\n    sql = f\"UPDATE board SET name='{name}' WHERE content_id='{content_id}'\"\n    with connection.cursor() as cur:\n        cur.execute(sql)\n    return HttpResponse('ok')"
        },
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from app.models import Member\n\ndef member_search(request):\n    name = request.POST.get('name', '')\n    # raw에 사용자 입력을 그대로 포함 → SQLi\n    q = \"SELECT * FROM member WHERE name='\" + name + \"'\"\n    data = Member.objects.raw(q)\n    return render(request, 'member_list.html', {'member_list': data})"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (바인딩)",
          "page": 0,
          "code": "from django.db import connection\n\ndef update_board(request):\n    name = request.POST.get('name', '')\n    content_id = request.POST.get('content_id', '')\n    with connection.cursor() as cur:\n        cur.execute(\"UPDATE board SET name=%s WHERE content_id=%s\", [name, content_id])\n    return HttpResponse('ok')"
        },
        {
          "label": "안전한 코드 예시 (raw + params)",
          "page": 0,
          "code": "from app.models import Member\n\ndef member_search(request):\n    name = request.POST.get('name', '')\n    sql = \"SELECT * FROM member WHERE name=%s\"\n    data = Member.objects.raw(sql, [name])\n    return render(request, 'member_list.html', {'member_list': data})"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 2,
      "korean_name": "코드 삽입",
      "english_type": "Code_Injection",
      "start_page": 14,
      "end_page": 17,
      "description": "eval/exec 등 동적 코드 실행에 사용자 입력이 흘러들어가면 임의 코드 실행으로 이어진다. 입력을 코드로 해석하는 API는 사용하지 말고, 반드시 필요한 경우 화이트리스트 기반으로 미리 정의한 동작만 선택하도록 제한한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "def request_rest_api(request):\n    func = request.POST.get('function_name', '')\n    # 사용자 입력을 그대로 실행 → RCE\n    exec(f\"{func}()\")\n    return HttpResponse('ok')"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (화이트리스트 디스패치)",
          "page": 0,
          "code": "def status():\n    return 'ok'\n\ndef ping():\n    return 'pong'\n\nALLOWED = {'status': status, 'ping': ping}\n\ndef request_rest_api(request):\n    func = request.POST.get('function_name', '')\n    if func not in ALLOWED:\n        return HttpResponseBadRequest('invalid function')\n    return HttpResponse(ALLOWED[func]())"
        }
      ],
      "recommendations": [
        "동적 코드 실행 API 사용 금지 혹은 강력한 화이트리스트 적용"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 3,
      "korean_name": "경로 조작 및 자원 삽입",
      "english_type": "Path_Traversal",
      "start_page": 18,
      "end_page": 21,
      "description": "파일명/포트/소켓 등 자원 식별자에 외부 입력을 그대로 사용하면 경로순회, 임의 바인딩 등 보안 문제가 발생한다. 기준 디렉터리 고정, 정규화 후 경계 확인, 확장자·파일명 화이트리스트, 포트/리소스 허용목록 등을 적용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (파일 경로)",
          "page": 0,
          "code": "import os\n\ndef read_file(request):\n    filename = request.POST.get('filename', '')\n    # 상대경로 포함 가능 → ../../etc/passwd 등\n    with open(filename, 'rb') as f:\n        return HttpResponse(f.read(), content_type='application/octet-stream')"
        },
        {
          "label": "안전하지 않은 코드 예시 (소켓 바인딩)",
          "page": 0,
          "code": "import socket\n\ndef bind_port(request):\n    port = int(request.POST.get('port', '0'))\n    s = socket.socket()\n    s.bind(('127.0.0.1', port))  # 임의 포트 사용 → 충돌/오남용\n    s.listen(1)\n    return HttpResponse('ok')"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (경로 정규화/검사)",
          "page": 0,
          "code": "import os\nfrom django.http import HttpResponse, HttpResponseBadRequest\n\nBASE_DIR = \"/srv/app/uploads\"\nALLOWED_EXT = {'.txt', '.log'}\n\ndef read_file(request):\n    name = request.POST.get('filename', '')\n    root = os.path.abspath(BASE_DIR)\n    target = os.path.abspath(os.path.join(root, name))\n    # 기준 경로 내부인지 확인\n    if not target.startswith(root + os.sep):\n        return HttpResponseBadRequest('invalid path')\n    _, ext = os.path.splitext(target)\n    if ext.lower() not in ALLOWED_EXT:\n        return HttpResponseBadRequest('blocked ext')\n    with open(target, 'rb') as f:\n        return HttpResponse(f.read(), content_type='text/plain')"
        },
        {
          "label": "안전한 코드 예시 (포트 허용목록)",
          "page": 0,
          "code": "import socket\nALLOWED_PORTS = {8000, 8080}\n\ndef bind_port(request):\n    port = int(request.POST.get('port', '0'))\n    if port not in ALLOWED_PORTS:\n        return HttpResponseBadRequest('blocked port')\n    s = socket.socket()\n    s.bind(('127.0.0.1', port))\n    s.listen(1)\n    return HttpResponse('ok')"
        }
      ],
      "recommendations": [
        "기준 디렉토리 고정, 경로 정규화 및 경계 확인, 허용 확장자/자원만 사용"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 4,
      "korean_name": "크로스사이트 스크립트(XSS)",
      "english_type": "XSS",
      "start_page": 22,
      "end_page": 28,
      "description": "신뢰되지 않은 데이터가 HTML/JS 컨텍스트로 이스케이프 없이 반영되면 스크립트가 실행된다. 서버 렌더링 시 템플릿 자동 이스케이프를 사용하고, 위험한 필터/옵션(safe, autoescape off)을 피한다. 필요 시 html.escape 등으로 컨텍스트에 맞게 인코딩한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (Django 템플릿)",
          "page": 0,
          "code": "{% autoescape off %}\n{{ content }}  {# XSS 가능 #}\n{% endautoescape %}\n<!-- 또는 -->\n{{ content|safe }}  {# 신뢰되지 않은 데이터에 사용 금지 #}"
        },
        {
          "label": "안전하지 않은 코드 예시 (파이썬에서 문자열 합성)",
          "page": 0,
          "code": "def profile_link(request):\n    url = request.POST.get('profile_url', '')\n    name = request.POST.get('profile_name', '')\n    # 태그 직접 합성 → XSS\n    link = f'<a href=\"{url}\">{name}</a>'\n    return render(request, 'my_profile.html', {'object_link': link})"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (자동 이스케이프 사용)",
          "page": 0,
          "code": "{# Django/Jinja 기본 autoescape 유지, 안전한 변수 출력 #}\n<p>{{ content }}</p>"
        },
        {
          "label": "안전한 코드 예시 (Flask + html.escape)",
          "page": 0,
          "code": "import html\nfrom flask import render_template, request\n\n@app.post('/search')\ndef search():\n    kw = request.form.get('q', '')\n    return render_template('search.html', keyword=html.escape(kw))"
        }
      ],
      "recommendations": [
        "템플릿 자동 이스케이프 사용, 위험 필터 금지, 컨텍스트별 인코딩 적용"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 5,
      "korean_name": "운영체제 명령어 삽입",
      "english_type": "Command_Injection",
      "start_page": 29,
      "end_page": 32,
      "description": "os.system, subprocess(shell=True) 등에 외부 입력이 포함되면 명령어/인자 변조로 임의 명령 실행이 가능하다. shell=False로 명령과 인자를 목록으로 분리하고, 가능한 경우 화이트리스트로만 실행한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "import os\n\ndef execute_command(request):\n    cmd = request.POST.get('cmd', '')\n    os.system(cmd)  # 사용자 입력 실행 → Command Injection"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (화이트리스트 + shell=False)",
          "page": 0,
          "code": "import subprocess\n\nALLOWED = {\n    'date': ['date'],\n    'uptime': ['uptime']\n}\n\ndef execute_command(request):\n    key = request.POST.get('cmd', '')\n    if key not in ALLOWED:\n        return HttpResponseBadRequest('blocked')\n    subprocess.run(ALLOWED[key], check=True)  # shell=False 기본값\n    return HttpResponse('ok')"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 6,
      "korean_name": "위험한 형식 파일 업로드",
      "english_type": "File_Upload",
      "start_page": 33,
      "end_page": 35,
      "description": "확장자/크기/MIME/시그니처 검증 없이 저장하면 악성 스크립트, 과대 파일, 경로 조작 등으로 이어질 수 있다. 확장자 화이트리스트, 크기 제한, MIME·시그니처 확인, 저장 경로 고정과 안전한 파일명 사용이 필요하다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from django.core.files.storage import FileSystemStorage\n\ndef upload(request):\n    f = request.FILES['file']     # 검증 없음\n    fs = FileSystemStorage(location='media')\n    name = fs.save(f.name, f)     # 확장자/크기/MIME 미검증\n    return HttpResponse(name)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (확장자·크기·이름 검증)",
          "page": 0,
          "code": "import os\nfrom django.core.files.storage import FileSystemStorage\nfrom django.utils.text import get_valid_filename\n\nALLOWED_EXT = {'.jpg', '.jpeg', '.png'}\nMAX_SIZE = 5 * 1024 * 1024\n\ndef upload(request):\n    f = request.FILES.get('file')\n    if not f or f.size > MAX_SIZE:\n        return HttpResponseBadRequest('too large or missing')\n    ext = os.path.splitext(f.name)[1].lower()\n    if ext not in ALLOWED_EXT:\n        return HttpResponseBadRequest('blocked ext')\n    safe_name = get_valid_filename(os.path.basename(f.name))\n    fs = FileSystemStorage(location='media/uploads')\n    name = fs.save(safe_name, f)\n    return HttpResponse(name)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 7,
      "korean_name": "신뢰되지 않은 URL주소로 자동접속 연결",
      "english_type": "Open_Redirect",
      "start_page": 36,
      "end_page": 38,
      "description": "리다이렉트 대상 URL을 사용자 입력으로 신뢰하면 피싱/토큰탈취 등으로 악용될 수 있다. 허용 도메인 화이트리스트를 사용하거나, 상대경로만 허용하고 Django의 url_has_allowed_host_and_scheme 등 검증 유틸을 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from django.shortcuts import redirect\n\ndef go_next(request):\n    nxt = request.GET.get('next', '/')\n    return redirect(nxt)  # 임의 외부 사이트로 리다이렉트 가능"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (허용 호스트 검증)",
          "page": 0,
          "code": "from django.shortcuts import redirect\nfrom django.utils.http import url_has_allowed_host_and_scheme\n\nALLOWED_HOSTS = {\"example.com\"}\n\ndef go_next(request):\n    nxt = request.GET.get('next', '/')\n    if not url_has_allowed_host_and_scheme(nxt, allowed_hosts=ALLOWED_HOSTS):\n        nxt = '/'\n    return redirect(nxt)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 8,
      "korean_name": "부적절한 XML 외부 개체 참조",
      "english_type": "XXE",
      "start_page": 39,
      "end_page": 41,
      "description": "외부 엔티티(External Entity) 해석을 허용하면 내부 파일 읽기, SSRF 등이 가능하다. defusedxml 계열 파서를 사용하거나, 라이브러리 옵션으로 외부 엔티티/DTD를 비활성화한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from lxml import etree\n\ndef parse_xml(request):\n    data = request.body\n    # 기본 파서에서 외부 엔티티가 처리될 수 있음 (구성에 따라 XXE)\n    root = etree.fromstring(data)\n    return HttpResponse(root.tag)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (defusedxml 사용)",
          "page": 0,
          "code": "from defusedxml import ElementTree as ET\n\ndef parse_xml(request):\n    data = request.body\n    root = ET.fromstring(data)  # 외부 엔티티 비활성화된 안전 파서\n    return HttpResponse(root.tag)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 9,
      "korean_name": "XML 삽입",
      "english_type": "XML_Injection",
      "start_page": 42,
      "end_page": 43,
      "description": "XPath/XQuery 문자열을 사용자 입력으로 합성하면 쿼리 구조가 변조되어 비인가 데이터 접근이 가능하다. 변수 바인딩을 제공하는 API를 사용하거나, 필터링·화이트리스트를 적용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (XPath 문자열 결합)",
          "page": 0,
          "code": "from lxml import etree\n\ndef find_home(request):\n    user = request.POST.get('user', '')\n    tree = etree.parse('user.xml')\n    # 문자열 결합 → XPath Injection\n    expr = f\"//users/user[@name='{user}']/home/text()\"\n    return HttpResponse(','.join(tree.xpath(expr)))"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (변수 바인딩)",
          "page": 0,
          "code": "from lxml import etree\n\ndef find_home(request):\n    user = request.POST.get('user', '')\n    tree = etree.parse('user.xml')\n    # $name 변수 바인딩으로 구조 고정\n    return HttpResponse(','.join(tree.xpath(\"//users/user[@name=$name]/home/text()\", name=user)))"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 10,
      "korean_name": "LDAP 삽입",
      "english_type": "LDAP_Injection",
      "start_page": 44,
      "end_page": 47,
      "description": "LDAP 필터를 문자열 결합으로 만들면 특수문자를 통한 필터 우회가 가능하다. ldap3의 escape_filter_chars로 사용자 입력을 이스케이프하거나, 안전한 빌더를 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from ldap3 import Connection, Server\n\ndef search_user(request):\n    kw = request.POST.get('kw', '')\n    server = Server('ldap.example.com')\n    conn = Connection(server, 'cn=ro,dc=ex,dc=com', 'pw', auto_bind=True)\n    # 필터 문자열 결합 → LDAP Injection\n    conn.search('dc=ex,dc=com', f\"(cn={kw})\", attributes=['cn','mail'])\n    return HttpResponse(str(conn.entries))"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (escape_filter_chars)",
          "page": 0,
          "code": "from ldap3 import Connection, Server\nfrom ldap3.utils.conv import escape_filter_chars\n\ndef search_user(request):\n    kw = escape_filter_chars(request.POST.get('kw', ''))\n    server = Server('ldap.example.com')\n    conn = Connection(server, 'cn=ro,dc=ex,dc=com', 'pw', auto_bind=True)\n    conn.search('dc=ex,dc=com', f\"(cn={kw})\", attributes=['cn','mail'])\n    return HttpResponse(str(conn.entries))"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 11,
      "korean_name": "크로스사이트 요청 위조(CSRF)",
      "english_type": "CSRF",
      "start_page": 48,
      "end_page": 54,
      "description": "사용자가 의도하지 않은 요청이 인증된 세션 맥락에서 실행되는 공격. 서버는 폼/요청마다 난수 토큰을 포함시키고, 수신 시 토큰을 검증해야 한다. Django의 CSRF 미들웨어, Flask-WTF CSRFProtect 등을 활용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (보호 해제)",
          "page": 0,
          "code": "from django.views.decorators.csrf import csrf_exempt\n\n@csrf_exempt\ndef transfer(request):\n    # 토큰 검증 없음 → CSRF\n    ...\n    return HttpResponse('ok')"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (Django 기본 보호)",
          "page": 0,
          "code": "# settings.py - 'django.middleware.csrf.CsrfViewMiddleware' 활성화\n# 템플릿\n# <form method=\"post\">{% csrf_token %} ...</form>\n\ndef transfer(request):\n    if request.method == 'POST':\n        # 유효한 CSRF 토큰이 없으면 403\n        ...\n        return HttpResponse('ok')\n    return render(request, 'form.html')"
        },
        {
          "label": "안전한 코드 예시 (Flask-WTF)",
          "page": 0,
          "code": "from flask_wtf import CSRFProtect\ncsrf = CSRFProtect(app)\n\n@app.post('/transfer')\ndef transfer():\n    # 자동 CSRF 검증\n    ...\n    return 'ok'"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 12,
      "korean_name": "서버사이드 요청 위조",
      "english_type": "SSRF",
      "start_page": 55,
      "end_page": 57,
      "description": "서버가 외부 입력으로 지정된 URL로 요청을 보낼 때 내부망/메타데이터 서비스(169.254.169.254)로의 접근이 가능해질 수 있다. URL 스킴, 호스트/포트를 엄격히 제한하고 사설 IP 대역을 차단하며, 타임아웃과 리다이렉트 제한을 적용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "import requests\n\ndef fetch(request):\n    url = request.POST.get('url', '')\n    # 어떤 주소든 요청 → SSRF\n    return HttpResponse(requests.get(url).text)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (허용 목록 + 사설망 차단)",
          "page": 0,
          "code": "import ipaddress\nfrom urllib.parse import urlparse\nimport requests\n\nALLOWED_SCHEMES = {'https'}\nALLOWED_HOSTS = {'api.example.com', 'data.example.com'}\n\ndef is_private(host):\n    try:\n        ip = ipaddress.ip_address(host)\n        return ip.is_private or ip.is_loopback or ip.is_link_local\n    except ValueError:\n        return False\n\ndef fetch(request):\n    raw = request.POST.get('url', '')\n    u = urlparse(raw)\n    if u.scheme not in ALLOWED_SCHEMES:\n        return HttpResponseBadRequest('bad scheme')\n    if u.hostname not in ALLOWED_HOSTS or is_private(u.hostname):\n        return HttpResponseBadRequest('blocked host')\n    r = requests.get(u.geturl(), timeout=3, allow_redirects=False)\n    return HttpResponse(r.text)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 13,
      "korean_name": "HTTP 응답분할",
      "english_type": "HTTP_Response_Splitting",
      "start_page": 58,
      "end_page": 60,
      "description": "헤더 값에 CR/LF가 포함되면 첫 응답을 조기 종료하고 두 번째 응답에 임의 콘텐츠를 주입할 수 있다. 헤더에 사용하는 값은 CR(\\r), LF(\\n)를 제거하거나 프레임워크의 안전한 API를 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from django.http import HttpResponse\n\ndef set_cookie(request):\n    val = request.GET.get('name', 'x')  # \"abc\\r\\nX-Injected: yes\"\n    resp = HttpResponse('ok')\n    # CRLF 포함 값 사용 → 응답 분할\n    resp['Set-Cookie'] = f\"name={val}\"\n    return resp"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (CR/LF 제거 또는 API 사용)",
          "page": 0,
          "code": "from django.http import HttpResponse, BadHeaderError\n\ndef set_cookie(request):\n    val = request.GET.get('name', 'x')\n    # 간단한 정화\n    val = val.replace('\\r', '').replace('\\n', '')\n    resp = HttpResponse('ok')\n    # Django의 set_cookie는 헤더 검증 수행\n    resp.set_cookie('name', val, samesite='Lax', httponly=True)\n    return resp"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 14,
      "korean_name": "정수형 오버플로우",
      "english_type": "Integer_Overflow",
      "start_page": 61,
      "end_page": 63,
      "description": "파이썬 int는 임의 정밀도지만, NumPy 같은 고정폭 정수형으로 캐스팅하면 오버플로우가 난다. 큰 수 연산은 파이썬 int로 계산해 범위를 확인한 뒤 고정폭 타입으로 변환한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (고정폭 결과 손상)",
          "page": 0,
          "code": "import numpy as np\n\ndef pow64(n, p):\n    return np.power(n, p, dtype=np.int64)  # 범위 초과 시 wrap-around"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (범위 확인 후 변환)",
          "page": 0,
          "code": "import numpy as np\n\nI64_MAX = np.iinfo(np.int64).max\nI64_MIN = np.iinfo(np.int64).min\n\ndef pow64(n, p):\n    big = int(n) ** int(p)  # 파이썬 int로 먼저 계산\n    if big > I64_MAX or big < I64_MIN:\n        raise OverflowError('int64 overflow')\n    return np.int64(big)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 15,
      "korean_name": "보안기능 결정에 사용되는 부적절한 입력값",
      "english_type": "Input_Validation",
      "start_page": 64,
      "end_page": 66,
      "description": "권한·인증 등 보안 결정에 쿠키/히든필드/클라이언트 파라미터를 신뢰하면 위변조로 보호 우회가 가능하다. 서버 측 세션/토큰에 서명하고, 민감 결정을 서버 저장 상태와 재검증한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (클라이언트 입력 신뢰)",
          "page": 0,
          "code": "def init_password(request):\n    # 사용자가 보낸 role 파라미터 신뢰 → 인가 우회\n    role = request.POST.get('role', 'user')\n    if role == 'admin':\n        reset_password(...)\n    return HttpResponse('done')"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (서버 세션·DB 기반 판정)",
          "page": 0,
          "code": "def init_password(request):\n    role = request.session.get('role')  # 서버 저장 상태\n    if role != 'admin':\n        return HttpResponseForbidden()\n    user_id = request.POST.get('user_id')\n    user_mail = request.POST.get('user_email')\n    reset_password(user_id, user_mail)\n    return HttpResponse('ok')"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 16,
      "korean_name": "포맷 스트링 삽입",
      "english_type": "Format_String",
      "start_page": 67,
      "end_page": 68,
      "description": "사용자 입력을 포맷 문자열로 사용하면 예외/정보노출/비정상 동작이 발생할 수 있다. 포맷 문자열은 상수로 고정하고, 값만 자리표시에 바인딩한다. 로깅은 logger.info('x %s', val)처럼 분리한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "def render_msg(request):\n    fmt = request.POST.get('fmt', '%s')\n    val = request.POST.get('val', '')\n    return HttpResponse(fmt % val)  # 포맷 문자열이 외부 입력"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시",
          "page": 0,
          "code": "def render_msg(request):\n    val = request.POST.get('val', '')\n    # 포맷은 상수로 고정, 값만 삽입\n    return HttpResponse(\"Message: %s\" % val)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 1,
      "korean_name": "적절한 인증 없는 중요 기능 허용",
      "english_type": "Missing_Authentication",
      "start_page": 69,
      "end_page": 71,
      "description": "중요 기능(개인정보 조회, 결제, 설정 변경 등)에 인증 절차 없이 접근 가능하면 누구나 실행할 수 있다. 모든 민감 엔드포인트에 대해 인증(세션/토큰)을 강제하고, 미인증 요청은 즉시 차단한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시",
          "page": 0,
          "code": "from django.http import JsonResponse\n\ndef my_profile(request):\n    # 인증 여부 확인 없이 민감 데이터 반환\n    user_id = request.GET.get('user_id')\n    data = get_user_info(user_id)\n    return JsonResponse(data)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (Django 로그인 강제)",
          "page": 0,
          "code": "from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse\n\n@login_required\ndef my_profile(request):\n    data = get_user_info(request.user.id)\n    return JsonResponse(data)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 2,
      "korean_name": "부적절한 인가",
      "english_type": "Improper_Authorization",
      "start_page": 72,
      "end_page": 74,
      "description": "인증은 되었지만 리소스 소유권/역할 검사가 누락되면 IDOR 등으로 타인의 데이터에 접근할 수 있다. 모든 경로에서 서버 측 권한 확인(객체 수준 인가)을 수행해야 한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (IDOR)",
          "page": 0,
          "code": "def get_invoice(request):\n    invoice_id = request.GET.get('id')\n    # 현재 사용자와 소유 관계 확인 없음\n    inv = Invoice.objects.get(id=invoice_id)\n    return JsonResponse({'amount': inv.amount})"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (소유권 검증)",
          "page": 0,
          "code": "def get_invoice(request):\n    invoice_id = request.GET.get('id')\n    inv = Invoice.objects.filter(id=invoice_id, owner=request.user).first()\n    if not inv:\n        return HttpResponseForbidden()\n    return JsonResponse({'amount': inv.amount})"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 3,
      "korean_name": "중요한 자원에 대한 잘못된 권한 설정",
      "english_type": "Incorrect_Permission",
      "start_page": 75,
      "end_page": 76,
      "description": "로그/백업/키 파일 등에 과도한 파일 권한(예: 777)을 부여하면 비인가자가 읽기/변경 가능하다. 최소권한 원칙으로 생성 시점부터 제한 권한을 적용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (과도한 권한)",
          "page": 0,
          "code": "import os\n\nwith open('secrets.key', 'w') as f:\n    f.write(KEY_DATA)\n# 파일을 0777로 풀어버림\nos.chmod('secrets.key', 0o777)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (최소권한 생성)",
          "page": 0,
          "code": "import os\nimport stat\n\nfd = os.open('secrets.key', os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0o640)\nwith os.fdopen(fd, 'w') as f:\n    f.write(KEY_DATA)\n# 필요 시 디렉터리는 750, 파일은 640 수준으로 유지"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 4,
      "korean_name": "취약한 암호화 알고리즘 사용",
      "english_type": "Weak_Cryptography",
      "start_page": 77,
      "end_page": 80,
      "description": "MD5/SHA-1, DES 등 취약 알고리즘은 충돌/공격에 취약하다. 데이터 무결성은 SHA-256 이상, 대칭키는 AES-GCM/ChaCha20-Poly1305 등을 사용하고, 패스워드는 PBKDF2/bcrypt/argon2로 해시한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (취약 해시)",
          "page": 0,
          "code": "import hashlib\n\ndef store_password(pw):\n    # 솔트도 없이 SHA1 단순 해시 → 취약\n    digest = hashlib.sha1(pw.encode()).hexdigest()\n    save_user_hash(digest)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (Django 기본 해시)",
          "page": 0,
          "code": "from django.contrib.auth.hashers import make_password, check_password\n\ndef store_password(pw):\n    hashed = make_password(pw)  # PBKDF2+salt\n    save_user_hash(hashed)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 5,
      "korean_name": "암호화되지 않은 중요정보",
      "english_type": "Unencrypted_Data",
      "start_page": 81,
      "end_page": 84,
      "description": "중요정보를 평문 전송(HTTP) 또는 평문 저장하면 탈취/노출 위험이 높다. 전송은 TLS(HTTPS) 강제, 저장은 검증된 라이브러리로 암호화·키 분리 보관을 적용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (평문 전송)",
          "page": 0,
          "code": "import requests\n\n# verify 미사용, http 사용\nrequests.post('http://api.example.com/pay', json={'card': card_number})"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (HTTPS + 검증)",
          "page": 0,
          "code": "import requests\n\nrequests.post('https://api.example.com/pay', json={'card': card_number}, timeout=3)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 6,
      "korean_name": "하드코드된 중요정보",
      "english_type": "Hardcoded_Secrets",
      "start_page": 85,
      "end_page": 87,
      "description": "API 키, DB 비밀번호 등을 소스에 하드코딩하면 유출 시 교체가 어렵고 즉시 노출된다. 환경변수/비밀관리(Vault/KMS)로 주입하고 로테이션 가능하게 설계한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (하드코딩)",
          "page": 0,
          "code": "API_KEY = 'sk_live_ABCDEFG...'  # 코드에 노출\n\nclient = Client(api_key=API_KEY)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (환경변수/비밀관리)",
          "page": 0,
          "code": "import os\n\nAPI_KEY = os.environ['PAY_API_KEY']\nclient = Client(api_key=API_KEY)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 7,
      "korean_name": "충분하지 않은 키 길이 사용",
      "english_type": "Insufficient_Key_Length",
      "start_page": 88,
      "end_page": 90,
      "description": "짧은 키는 전수공격에 취약하다. RSA 2048비트 이상, ECC P-256 이상, AES-128/256 등을 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (RSA 1024)",
          "page": 0,
          "code": "from Crypto.PublicKey import RSA\n\n# 취약: 1024-bit\nkey = RSA.generate(1024)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (RSA 2048+ / ECC P-256+)",
          "page": 0,
          "code": "from Crypto.PublicKey import RSA\n# 권장: 2048-bit 이상\nkey = RSA.generate(2048)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 8,
      "korean_name": "적절하지 않은 난수 값 사용",
      "english_type": "Weak_Random",
      "start_page": 91,
      "end_page": 93,
      "description": "보안 토큰을 random 모듈로 생성하면 예측 가능하다. secrets 또는 os.urandom 기반 API를 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (예측 가능한 토큰)",
          "page": 0,
          "code": "import random\n\ndef make_token():\n    return str(random.randint(0, 10_000_000))"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (암호학적 난수)",
          "page": 0,
          "code": "import secrets\n\ndef make_token():\n    return secrets.token_urlsafe(32)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 9,
      "korean_name": "취약한 패스워드 허용",
      "english_type": "Weak_Password",
      "start_page": 94,
      "end_page": 97,
      "description": "길이/복잡도/사전 단어 검사가 없으면 취약한 패스워드를 허용한다. 프레임워크의 패스워드 검증기를 활성화하고 해시는 솔트 포함 KDF를 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (검증·해시 부재)",
          "page": 0,
          "code": "def register(request):\n    pw = request.POST['password']\n    # 규칙검사·해시 없이 DB 저장\n    User.objects.create(username=request.POST['id'], password=pw)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (Django 검증기 + 해시)",
          "page": 0,
          "code": "from django.contrib.auth.password_validation import validate_password\nfrom django.contrib.auth.hashers import make_password\n\ndef register(request):\n    pw = request.POST['password']\n    validate_password(pw, user=None)\n    User.objects.create(username=request.POST['id'], password=make_password(pw))"
        }
      ],
      "recommendations": [
        "누수된 흔한 비밀번호 차단, 2FA 도입 고려"
      ]
    },
    {
      "section": "제2절 보안기능",
      "number": 10,
      "korean_name": "부적절한 전자서명 확인",
      "english_type": "Improper_Signature_Verification",
      "start_page": 98,
      "end_page": 101,
      "description": "서명 미검증/잘못된 데이터에 대한 검증/단순 해시 비교는 변조를 탐지하지 못한다. 신뢰된 공개키로 원문 데이터에 대한 서명을 정확히 검증해야 한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (해시만 비교)",
          "page": 0,
          "code": "import hashlib\n\ndef verify(data, sig):\n    # 전달된 'sig'가 data의 sha256과 같으면 OK라고 착각\n    return hashlib.sha256(data).hexdigest() == sig"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (RSA-PSS 검증)",
          "page": 0,
          "code": "from cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\n\ndef verify(data: bytes, signature: bytes, pem_pub: bytes) -> bool:\n    pub = serialization.load_pem_public_key(pem_pub)\n    try:\n        pub.verify(signature, data, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256())\n        return True\n    except Exception:\n        return False"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 11,
      "korean_name": "부적절한 인증서 유효성 검증",
      "english_type": "Improper_Certificate_Validation",
      "start_page": 102,
      "end_page": 105,
      "description": "TLS 통신 시 인증서 검증을 비활성화하면 중간자 공격에 취약하다. 기본 검증을 사용하고 필요 시 신뢰 루트(CA) 번들을 명시한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (검증 끔)",
          "page": 0,
          "code": "import requests\n\n# verify=False → MiTM 노출\nrequests.get('https://example.com/api', verify=False)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시",
          "page": 0,
          "code": "import requests\n\nrequests.get('https://example.com/api', timeout=3)  # 기본 검증 활성\n# 혹은 조직 CA 번들을 명시적으로 사용"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 12,
      "korean_name": "사용자 하드디스크에 저장되는 쿠키를 통한 정보 노출",
      "english_type": "Cookie_Exposure",
      "start_page": 106,
      "end_page": 108,
      "description": "영속 쿠키에 권한/세션ID 등 민감정보를 저장하면 탈취·복제 위험이 커진다. 최소 정보만 저장하고 Secure/HttpOnly/SameSite를 설정하며, 가능하면 서버 측 세션을 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (민감정보 저장)",
          "page": 0,
          "code": "from django.http import HttpResponse\n\ndef login(request):\n    resp = HttpResponse('ok')\n    resp.set_cookie('role', 'admin')  # 평문 권한 노출\n    return resp"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (보안 속성)",
          "page": 0,
          "code": "from django.http import HttpResponse\n\ndef remember(request):\n    resp = HttpResponse('ok')\n    resp.set_cookie('remember', '1', max_age=1209600, secure=True, httponly=True, samesite='Lax')\n    return resp"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 13,
      "korean_name": "주석문 안에 포함된 시스템 주요정보",
      "english_type": "Information_in_Comments",
      "start_page": 109,
      "end_page": 110,
      "description": "주석에 크리덴셜/엔드포인트/키 등을 남기면 코드 노출 시 함께 유출된다. 주석에 민감정보를 쓰지 말고 보안 점검에서 주석도 스캔한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (주석 유출)",
          "page": 0,
          "code": "# PROD DB: user=admin, pass=P@ssw0rd!\n# SSH: root@10.0.0.5\ndef connect():\n    ..."
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시",
          "page": 0,
          "code": "# 민감정보는 주석에 금지. 필요 시 보안 문서/비밀관리 사용.\ndef connect():\n    ..."
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 14,
      "korean_name": "솔트 없이 일방향 해시 함수 사용",
      "english_type": "Missing_Salt",
      "start_page": 111,
      "end_page": 112,
      "description": "솔트 없는 단순 해시는 레인보우 테이블 공격에 취약하다. 사용자별 랜덤 솔트를 포함하는 KDF(PBKDF2/bcrypt/argon2)를 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (솔트 없음)",
          "page": 0,
          "code": "import hashlib\n\ndef hash_pw(pw):\n    return hashlib.sha256(pw.encode()).hexdigest()"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (PBKDF2)",
          "page": 0,
          "code": "import os, hashlib\n\ndef hash_pw(pw):\n    salt = os.urandom(16)\n    dk = hashlib.pbkdf2_hmac('sha256', pw.encode(), salt, 200000)\n    return salt.hex() + ':' + dk.hex()"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 15,
      "korean_name": "무결성 검사없는 코드 다운로드",
      "english_type": "Unverified_Download",
      "start_page": 113,
      "end_page": 115,
      "description": "코드/바이너리를 무결성 검증 없이 내려받아 실행하면 변조된 파일을 실행할 수 있다. 신뢰 채널로 내려받고 서명/해시를 검증한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (무검증 실행)",
          "page": 0,
          "code": "import urllib.request\n\ncode = urllib.request.urlopen(url).read().decode()\nexec(code)  # 원격 코드 직접 실행 금지"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (해시 검증)",
          "page": 0,
          "code": "import hashlib, urllib.request\n\nexpected = '...sha256hex...'\nblob = urllib.request.urlopen(url).read()\nif hashlib.sha256(blob).hexdigest() != expected:\n    raise ValueError('tampered')\n# 검증 통과 시에도 자동 실행은 금지"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 16,
      "korean_name": "반복된 인증시도 제한 기능 부재",
      "english_type": "Missing_Brute_Force_Protection",
      "start_page": 116,
      "end_page": 118,
      "description": "로그인 시도 횟수 제한이 없으면 무차별 대입 공격에 취약하다. 사용자/IP별로 시도 횟수를 제한하고, 캡차·지연·2FA를 적용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (제한 없음)",
          "page": 0,
          "code": "def login(request):\n    user = auth(request.POST['id'], request.POST['pw'])\n    return HttpResponse('ok' if user else 'fail')"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (횟수 제한)",
          "page": 0,
          "code": "from django.core.cache import cache\n\nLIMIT = 5\nWINDOW = 900  # 15분\n\ndef login(request):\n    key = f\"lf:{request.META.get('REMOTE_ADDR')}:{request.POST.get('id')}\"\n    cnt = cache.get(key, 0)\n    if cnt >= LIMIT:\n        return HttpResponseTooManyRequests()\n    user = auth(request.POST['id'], request.POST['pw'])\n    if user:\n        cache.delete(key)\n        return HttpResponse('ok')\n    cache.set(key, cnt+1, WINDOW)\n    return HttpResponse('fail')"
        }
      ],
      "recommendations": []
    },

    {
      "section": "제3절 시간 및 상태",
      "number": 1,
      "korean_name": "경쟁조건: 검사시점과 사용시점(TOCTOU)",
      "english_type": "TOCTOU",
      "start_page": 119,
      "end_page": 121,
      "description": "검사 시점과 사용 시점 사이에 대상의 상태가 바뀌면 보안 검사가 무력화된다. 파일 작업은 원자적 생성/락을 사용하고, 공유자원 접근은 락으로 보호한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (exists 후 open)",
          "page": 0,
          "code": "import os\n\ndef create_temp(path):\n    if not os.path.exists(path):  # 검사\n        f = open(path, 'w')       # 사이에 다른 프로세스가 개입 가능\n        f.write('data'); f.close()"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (원자적 생성)",
          "page": 0,
          "code": "import os\n\ndef create_temp(path):\n    fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_WRONLY)\n    with os.fdopen(fd, 'w') as f:\n        f.write('data')"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제3절 시간 및 상태",
      "number": 2,
      "korean_name": "종료되지 않는 반복문 또는 재귀 함수",
      "english_type": "Infinite_Loop",
      "start_page": 122,
      "end_page": 124,
      "description": "종료 조건이 불명확하거나 입력에 의해 조작되면 무한루프/과도한 재귀가 발생한다. 명확한 종료 조건과 한도를 설정하고, 가능하면 반복형으로 구현한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (종료 조건 없음)",
          "page": 0,
          "code": "def wait_ready():\n    while not is_ready():\n        pass  # 바쁜대기, 종료 불가"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (타임아웃/슬립)",
          "page": 0,
          "code": "import time\n\ndef wait_ready(timeout=5):\n    end = time.time() + timeout\n    while time.time() < end:\n        if is_ready():\n            return True\n        time.sleep(0.1)\n    return False"
        }
      ],
      "recommendations": []
    },

    {
      "section": "제4절 에러처리",
      "number": 1,
      "korean_name": "오류 메시지 정보노출",
      "english_type": "Error_Message_Exposure",
      "start_page": 125,
      "end_page": 128,
      "description": "스택트레이스/환경 정보가 사용자에게 노출되면 침해에 악용된다. 운영 환경에서는 사용자에게 일반화된 메시지만 제공하고 상세 정보는 서버 로그로 제한한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (예외 직접 노출)",
          "page": 0,
          "code": "def fetch(url):\n    try:\n        return requests.get(url).text\n    except Exception as e:\n        return str(e)  # 내부 오류 메시지 노출"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (일반화된 응답 + 로깅)",
          "page": 0,
          "code": "import logging\nlogger = logging.getLogger(__name__)\n\ndef fetch(url):\n    try:\n        return requests.get(url, timeout=3).text\n    except requests.RequestException as e:\n        logger.exception('fetch failed')\n        return '서비스 이용 중 오류가 발생했습니다.'"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제4절 에러처리",
      "number": 2,
      "korean_name": "오류상황 대응 부재",
      "english_type": "Missing_Error_Handling",
      "start_page": 129,
      "end_page": 131,
      "description": "실패 가능성이 있는 작업에 대한 예외처리가 없으면 시스템이 중단되거나 데이터가 손상된다. 실패를 예측하고 적절한 복구/롤백/대체 경로를 구현한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (예외 미처리)",
          "page": 0,
          "code": "def pay():\n    charge_card()  # 실패 시 전파되어 사용자에게 스택 노출"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (롤백/대체 응답)",
          "page": 0,
          "code": "def pay():\n    try:\n        charge_card()\n        return 'ok'\n    except PaymentError:\n        rollback()\n        return '결제에 실패했습니다.'"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제4절 에러처리",
      "number": 3,
      "korean_name": "부적절한 예외 처리",
      "english_type": "Improper_Exception_Handling",
      "start_page": 132,
      "end_page": 133,
      "description": "모든 예외를 포괄적으로 삼키면 오류를 은폐하고 취약점을 남긴다. 구체적인 예외를 처리하고 필요한 경우 재전파한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (bare except)",
          "page": 0,
          "code": "try:\n    i = int(request.GET['n'])\nexcept:\n    i = 0  # 원인 은폐"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (구체적 처리)",
          "page": 0,
          "code": "try:\n    i = int(request.GET.get('n', '0'))\nexcept (TypeError, ValueError):\n    return HttpResponseBadRequest('invalid number')"
        }
      ],
      "recommendations": []
    },

    {
      "section": "제5절 코드오류",
      "number": 1,
      "korean_name": "Null Pointer 역참조",
      "english_type": "Null_Pointer_Dereference",
      "start_page": 134,
      "end_page": 136,
      "description": "파이썬에는 Null 포인터는 없지만 None 사용 시 속성 접근/호출에서 예외가 발생할 수 있다. None 가능 값은 사전 검증하거나 기본값을 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (None 접근)",
          "page": 0,
          "code": "filename = request.POST.get('filename')\nwith open(filename) as f:  # filename이 None이면 예외\n    data = f.read()"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (검증)",
          "page": 0,
          "code": "filename = (request.POST.get('filename') or '').strip()\nif not filename:\n    return HttpResponseBadRequest('missing filename')\nwith open(filename) as f:\n    data = f.read()"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제5절 코드오류",
      "number": 2,
      "korean_name": "부적절한 자원 해제",
      "english_type": "Improper_Resource_Release",
      "start_page": 137,
      "end_page": 139,
      "description": "파일·소켓·락 등을 해제하지 않으면 자원 고갈/교착이 발생한다. 컨텍스트 매니저(with)나 finally 블록으로 해제를 보장한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (close 누락)",
          "page": 0,
          "code": "f = open('log.txt', 'a')\nf.write('hi')  # 예외 발생 시 닫히지 않음"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (with)",
          "page": 0,
          "code": "with open('log.txt', 'a') as f:\n    f.write('hi')"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제5절 코드오류",
      "number": 3,
      "korean_name": "신뢰할 수 없는 데이터의 역직렬화",
      "english_type": "Unsafe_Deserialization",
      "start_page": 140,
      "end_page": 142,
      "description": "pickle/yaml의 불안전한 로드는 임의 코드 실행을 유발할 수 있다. 신뢰되지 않은 입력은 JSON 같은 안전한 포맷으로 처리하거나, 서명/검증을 수행한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (pickle.loads)",
          "page": 0,
          "code": "import pickle\n\ndef load_user(blob):\n    obj = pickle.loads(blob)  # RCE 위험\n    return obj"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (JSON 사용)",
          "page": 0,
          "code": "import json\n\ndef load_user(blob):\n    return json.loads(blob.decode('utf-8'))"
        }
      ],
      "recommendations": []
    },

    {
      "section": "제6절 캡슐화",
      "number": 1,
      "korean_name": "잘못된 세션에 의한 데이터 정보 노출",
      "english_type": "Session_Data_Exposure",
      "start_page": 143,
      "end_page": 145,
      "description": "클래스 변수(공유 상태)나 전역을 세션 데이터 보관에 사용하면 사용자 간 데이터가 섞인다. 인스턴스 변수나 요청/세션 저장소를 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (클래스 변수 공유)",
          "page": 0,
          "code": "class Profile:\n    cache = {}\n    def set_name(self, request):\n        Profile.cache['name'] = request.POST.get('name')  # 세션 간 공유"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (세션 저장)",
          "page": 0,
          "code": "def set_name(request):\n    request.session['name'] = request.POST.get('name', '')"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제6절 캡슐화",
      "number": 2,
      "korean_name": "제거되지 않고 남은 디버그 코드",
      "english_type": "Debug_Code",
      "start_page": 146,
      "end_page": 149,
      "description": "디버그 모드는 내부 정보/원격 코드 실행 위험을 노출한다. 운영 환경에서는 반드시 비활성화한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (Flask debug)",
          "page": 0,
          "code": "app = Flask(__name__)\napp.debug = True\napp.run(debug=True)"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시",
          "page": 0,
          "code": "app = Flask(__name__)\n# 환경변수로만 제어, 기본 False\nif __name__ == '__main__':\n    app.run()"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제6절 캡슐화",
      "number": 3,
      "korean_name": "Public 메소드로부터 반환된 Private 배열",
      "english_type": "Private_Array_Return",
      "start_page": 150,
      "end_page": 151,
      "description": "내부 리스트를 그대로 반환하면 외부에서 수정 가능하다. 사본을 반환하거나 불변 구조로 변환한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (참조 노출)",
          "page": 0,
          "code": "class C:\n    def __init__(self):\n        self._items = []\n    def get_items(self):\n        return self._items  # 외부 수정 가능"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (사본/불변 반환)",
          "page": 0,
          "code": "class C:\n    def __init__(self):\n        self._items = []\n    def get_items(self):\n        return tuple(self._items)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제6절 캡슐화",
      "number": 4,
      "korean_name": "Private 배열에 Public 데이터 할당",
      "english_type": "Public_Data_Assignment",
      "start_page": 152,
      "end_page": 153,
      "description": "외부에서 받은 변경 가능한 객체를 내부 상태에 그대로 보관하면 외부 변경이 내부에 전파된다. 검증 후 복사본을 저장한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (직접 대입)",
          "page": 0,
          "code": "class C:\n    def set_items(self, lst):\n        self.__items = lst  # 외부 참조 공유"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (복사 저장)",
          "page": 0,
          "code": "class C:\n    def set_items(self, lst):\n        self.__items = list(lst)  # 사본 보관"
        }
      ],
      "recommendations": []
    },

    {
      "section": "제7절 API 오용",
      "number": 1,
      "korean_name": "DNS lookup에 의존한 보안결정",
      "english_type": "DNS_Based_Security",
      "start_page": 154,
      "end_page": 155,
      "description": "도메인/역방향 DNS 결과만으로 접근 허용을 결정하면 스푸핑/캐시 오염에 취약하다. 네트워크 레벨 제어(IP/서브넷 화이트리스트)와 TLS 상호 인증 등 강한 검증을 사용한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (DNS 이름만 신뢰)",
          "page": 0,
          "code": "import socket\n\ndef allow(addr):\n    host = socket.gethostbyaddr(addr)[0]\n    return host.endswith('.trusted.local')"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (CIDR 확인)",
          "page": 0,
          "code": "import ipaddress\n\nTRUSTED = [ipaddress.ip_network('203.0.113.0/24')]\n\ndef allow(addr):\n    ip = ipaddress.ip_address(addr)\n    return any(ip in n for n in TRUSTED)"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제7절 API 오용",
      "number": 2,
      "korean_name": "취약한 API 사용",
      "english_type": "Vulnerable_API",
      "start_page": 156,
      "end_page": 170,
      "description": "취약하거나 오용하기 쉬운 API(pickle, yaml.load 등)를 사용하면 RCE/정보노출로 이어질 수 있다. 안전 대체 API를 사용하거나 안전 모드로 제한한다.",
      "unsafe_codes": [
        {
          "label": "안전하지 않은 코드 예시 (PyYAML load)",
          "page": 0,
          "code": "import yaml\n\ndef parse(s):\n    return yaml.load(s)  # 로더 지정 없이 오브젝트 생성 가능"
        }
      ],
      "safe_codes": [
        {
          "label": "안전한 코드 예시 (safe_load)",
          "page": 0,
          "code": "import yaml\n\ndef parse(s):\n    return yaml.safe_load(s)"
        }
      ],
      "recommendations": []
    }
  ]
}
