{
  "vulnerabilities": [
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 1,
      "korean_name": "SQL 삽입",
      "english_type": "SQL_Injection",
      "start_page": 8,
      "end_page": 13,
      "description": "데이터베이스(DB)와 연동된 웹 응용프로그램에서 입력된 데이터에 대한 유효성 검증을 하지 않을 경우 공격자가\n입력 폼 및 URL 입력란에 SQL 문을 삽입하여 DB로부터 정보를 열람하거나 조작할 수 있는 보안약점을 말한다.\n취약한 웹 응용프로그램에서는 사용자로부터 입력된 값을 검증 없이 넘겨받아 동적쿼리(Dynamic Query)를\n생성하기 때문에 개발자가 의도하지 않은 쿼리가 실행되어 정보유출에 악용될 수 있다.\n\n\n\nPython 시큐어코딩 가이드\n안전하지 않은 코드 예시\n1: from django.shortcuts import render\n2: from django.db import connection\n3:\n4: def update_board(request):\n5: ......\n6: dbconn = connection\n7:\n8: with dbconn.cursor() as curs:\n9: # 외부로부터 입력받은 값을 검증 없이 사용할 경우 안전하지 않다\n10: name = request.POST.get('name', '')\n11: content_id = request.POST.get('content_id', '')\n12:\n13: # 사용자의 검증되지 않은 입력값을 사용해 동적 쿼리문 생성\n14: sql_query = \"update board set name='\" + name + \"' where content_id='“ + content_id + \"'\"\n15:\n16: # 외부 입력값이 검증 없이 쿼리로 포함되어 안전하지 않다\n17: curs.execute(sql_query)\n18: dbconn.commit()\n19:\n20: return render(request, '/success.html')\n다음은 이를 안전한 코드로 변환한 예시를 보여준다. 앞선 예제와 달리 입력 받은 외부 입력값을 그대로\n사용하지 않고 인자화된 쿼리 생성 후(line 11) execute() 메서드의 두 번째 인자 값으로 이 값을 바인딩 해서\n쿼리문을 실행한다(line 15). 이렇게 매개변수 바인딩을 통해 execute() 함수를 호출하면 공격자가 쿼리를 변조\n하는 값을 삽입하더라도 해당 값이 바인딩된 매개변수의 값으로만 사용되기 때문에 안전하다.\n\n\n\nPython 시큐어코딩 가이드\n안전하지 않은 코드 예시\n1: from django.shortcuts import render\n2: from app.models import Member\n3:\n4: def member_search(request):\n5: name = request.POST.get('name', '')\n6:\n7: # 입력값을 검증 없이 쿼리문 생성에 사용해 안전하지 않다\n8: query=“select * from member where name=‘” + name + “’”\n9:\n10: # 외부 입력값을 검증 없이 사용한 쿼리문을 raw()함수로 실행하면 안전하지 않다\n11: data = Member.objects.raw(query)\n12: return render(request, '/member_list.html', {'member_list':data})\n다음 코드에서는 Django에서 원시 코드 실행 시에도 인자화된 쿼리와 params 인수를 raw() 함수의 바인딩\n변수로 사용하는 안전한 예시를 보여 준다. 외부 입력값을 포함하는 쿼리문 생성 자체를 인자화된 쿼리 형식으로\n생성하고(line 10), raw() 메소드에서 두 번째 인자의 바인딩 변수로 사용했다.\n안전한 코드 예시\n1: from django.shortcuts import render\n2: from app.models import Member\n3:\n4: def member_search(request):\n5: name = request.POST.get('name', '')\n6:\n7: # 외부 입력값을 raw() 함수 실행 시 바인딩 변수로 사용하여 쿼리 구조가\n8: # 변경되지 않도록 한다.(list 형은 %s, dictionary 형은 %(key)s를 사용)\n9: query='select * from member where name=%s'\n10:\n11: # 인자화된 쿼리문을 사용하여 raw() 함수를 호출해 안전하다\n12: data = Member.objects.raw(query, [name])\n13: return render(request, '/member_list.html', {'member_list':data})",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 2,
      "korean_name": "코드 삽입",
      "english_type": "Code_Injection",
      "start_page": 14,
      "end_page": 17,
      "description": "공격자가 소프트웨어의 의도된 동작을 변경하도록 임의 코드를 삽입해 소프트웨어가 비정상적으로 동작하도록\n하는 보안약점을 말한다. 코드 삽입은 프로그래밍 언어 자체의 기능에 한해 이뤄진다는 점에서 운영체제 명령어\n삽입과 다르다. 프로그램에서 사용자의 입력값 내에 코드가 포함되는 것을 허용할 경우 공격자는 개발자가 의도\n하지 않은 코드를 실행해 권한을 탈취하거나 인증 우회, 시스템 명령어 실행 등을 할 수 있다.\n파이썬에서 코드 삽입 공격을 유발할 수 있는 함수로는 eval(), exec() 등이 있다. 해당 함수의 인자를 면밀히\n검증하지 않는 경우 공격자가 전달한 코드가 그대로 실행될 수 있다.",
      "unsafe_codes": [
        {
          "code": "가) eval()함수 사용 예제\n다음은 안전하지 않은 코드로 eval()을 사용해 사용자로부터 입력받은 값을 실행하여 결과를 반환 하는 예제다.\n외부로부터 입력 받은 값을 아무런 검증 없이 eval() 함수의 인자로 사용하고 있다(line 10).\n\n\n\nPython 시큐어코딩 가이드\n파이썬은 다양한 String 메소드를 제공하고 있다. 필요한 경우 적절한 메소드를 사용해 외부 입력값에 대한\n검증을 수행해야 한다. 아래는 파이썬에서 제공하는 입력값 검증용 String 메소드 예시를 보여 준다.\n⦁str.isalpha() : 문자열 내의 모든 문자가 알파벳이고, 적어도 하나의 문자가 존재하는 경우 True를 반환\n⦁str.isdecimal() : 문자열 내의 모든 문자가 십진수 문자이고, 적어도 하나의 문자가 존재하는 경우 True를 반환\n⦁str.isdigit() : 문자열 내의 모든 문자가 숫자이고, 적어도 하나의 문자가 존재하는 경우 True를 반환,\n십진수 문자와 호환되는 위 첨자 숫자와 같은 숫자도 포함. ex) ‘52’ 는 True를 반환\n입력값 검증 시 외부 입력값이 특정 형식을 따라야 하는 경우 정규 표현식을 이용해 검증을 할 수 있다.\n파이썬에서는 re 라이브러리를 사용해 정규식 기반 검증이 가능하다. 예를 들어 이메일 형식의 입력만 허용하고\n싶은 경우 다음과 같은 정규식을 사용하면 된다.\nex) prog = re.compile(r'([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})+')\n나) exec()함수 사용 예제\n다음은 exec() 함수를 사용한 안전하지 않은 코드 예제를 보여 준다. 외부 입력값을 검증 없이 exec 함수의\n인자로 사용하고 있다(line 9). 이렇게 되면 중요 데이터 탈취 및 서버의 권한 탈취, 액세스 거부, 심지어 완전한\n호스트 탈취로도 이어질 수 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from django.shortcuts import render\n2:\n3: def request_rest_api(request):\n4: function_name = request.POST.get('function_name', '')\n5:\n6: # 사용자에게 전달받은 함수명을 검증하지 않고 실행\n7: # 입력값으로 “__import__(‘platform’).system()” 등을 입력 시\n8: # 시스템 정보 노출 위험이 있다\n9: exec('{}()'.format(function_name))\n10:\n11: return render(request, '/success.html')",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "동적코드를 실행할 수 있는 함수를 사용하지 않는다. 필요 시, 실행 가능한 동적 코드를 입력값으로 받지",
        "않도록 외부 입력값에 대해 화이트리스트 기반 검증을 수행해야 한다. 유효한 문자만 포함하도록 동적 코드에",
        "사용되는 사용자 입력값을 필터링 하는 방법도 있다."
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 3,
      "korean_name": "경로 조작 및 자원 삽입",
      "english_type": "Path_Traversal",
      "start_page": 18,
      "end_page": 21,
      "description": "검증되지 않은 외부 입력값을 통해 파일 및 서버 등 시스템 자원(파일, 소켓의 포트 등)에 대한 접근 혹은\n식별을 허용할 경우 입력값 조작으로 시스템이 보호하는 자원에 임의로 접근할 수 있는 보안약점이다. 경로조작\n및 자원삽입 약점을 이용해 공격자는 자원 수정·삭제, 시스템 정보누출, 시스템 자원 간 충돌로 인한 서비스\n장애 등을 유발시킬 수 있다. 또한 경로 조작 및 자원 삽입을 통해서 공격자가 허용되지 않은 권한을 획득해\n설정 파일을 변경하거나 실행시킬 수 있다.\n파이썬에서는 subprocess.popen()과 같이 프로세스를 여는 함수, os.pipe()처럼 파이프를 여는 함수,\nsocket 연결 등에서 외부 입력값을 검증 없이 사용할 경우 경로 조작 및 자원 삽입의 취약점이 발생할 수 있다.",
      "unsafe_codes": [
        {
          "code": "가) 경로 조작 예제\n다음은 외부 입력값으로 파일 경로 등을 입력받아 파일을 여는 예시를 보여 준다. 만약 공격자가\n‘../../../../etc/passwd’ 와 같은 값을 전달하면 사용자 계정 및 패스워드 정보가 담긴 파일의 내용이 클라이언트\n측에 표시되어 의도치 않은 시스템 정보노출 문제가 발생한다.\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "17:\n18: try:\n19: with open(filename + file_ext) as f:\n21: data = f.read()\n22: except:\n23: return render(\n24: request, \"/error.html\", {\"error\": \"파일이 존재하지 않거나 열 수 없는 파일입니다.\"}\n25: )\n26:\n27: return render(request, '/success.html', {'data':data})\n나) 자원 삽입 예제\n다음은 안전하지 않은 코드 예시로, 외부 입력을 소켓 포트 번호로 그대로 사용하고 있다. 외부 입력값을\n검증 없이 사용할 경우 기존 자원과의 충돌로 의도치 않은 에러가 발생할 수 있다.\n안전하지 않은 코드 예시\n1: import socket\n2: from django.shortcuts import render\n3:\n4: def get_info(request):\n5: port = int(request.POST.get('port'))\n6:\n7: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n8: # 외부로부터 입력받은 검증되지 않은 포트 번호를 이용하여\n9: # 소켓을 바인딩하여 사용하고 있어 안전하지 않다\n10: s.bind(('127.0.0.1', port))\n11: ...\n12: return render(request, '/success.html')\n13: return render(request, '/error.html', {'error':'소켓연결 실패'})\n다음은 안전한 예제를 보여 준다. 내부 자원에 접근 시 외부에서 입력 받은 값을 포트 번호와 같은 식별자로\n그대로 사용하는 것은 바람직하지 않으며, 꼭 필요한 경우엔 허용 가능한 목록을 설정한 후 목록 내에 포함된\n포트만 할당되도록 코드를 작성해야 한다.",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": [
        "외부로부터 받은 입력값을 자원(파일, 소켓의 포트 등)의 식별자로 사용하는 경우 적절한 검증을 거치도록",
        "하거나 사전에 정의된 리스트에 포함된 식별자만 사용하도록 해야 한다. 특히 외부의 입력이 파일명인 경우에는",
        "필터를 적용해 경로순회(directory traversal) 공격의 위험이 있는 문자( /, \\, .. 등)를 제거해야 한다."
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 4,
      "korean_name": "크로스사이트 스크립트(XSS)",
      "english_type": "XSS",
      "start_page": 22,
      "end_page": 28,
      "description": "크로스사이트 스크립트 공격(Cross-site scripting Attacks)은 웹사이트에 악성 코드를 삽입하는 공격 방법\n이다. 공격자는 대상 웹 응용프로그램의 결함을 이용해 악성코드(일반적으로 클라이언트 측 JavaScript 사용)를\n사용자에게 보낸다. XSS공격은 일반적으로 애플리케이션 호스트 자체보다 사용자를 목표로 삼는다.\nXSS는 공격자가 웹 응용프로그램을 속여 브라우저에서 실행될 수 있는 형식의 데이터(코드)를 다른 사용자\n에게 전달할 때 발생한다. 공격자가 임의로 구성한 기본 웹 코드 외에도 악성코드 다운로드, 플러그인 또는\n미디어 콘텐츠를 이용할 수도 있다. 사용자가 폼 양식에 입력한 데이터 또는 서버에서 클라이언트 단말(브라우저)\n전달된 데이터가 적절한 검증 없이 사용자에게 표시되도록 허용되는 경우 발생한다.\nXSS공격에는 크게 세 가지 유형의 공격방법이 있다.\n⦁유형 1 : Reflective XSS (or Non-persistent XSS)\n\n\n\nPython 시큐어코딩 가이드\n- 공격자는 DOM XSS 공격을 통해 세션 및 개인 정보를 포함한 쿠키 데이터를 피해자의 컴퓨터에서 공격자\n시스템으로 전송할 수 있다. 이 정보를 사용해 특정 웹사이트에 악의적인 요청을 보낼 수 있으며, 피해자가\n해당 사이트를 관리 할 수 있는 관리자 권한이 있는 경우 심각한 위협을 초래할 수도 있다. 또한 신뢰할\n수 있는 웹 사이트를 모방하고 피해자가 암호를 입력하도록 속여 공격자가 해당 웹 사이트에서 피해자의\n계정을 손상시키는 피싱(Phishing) 공격으로도 이어질 수 있다.\n- 파이썬에서 가장 많이 사용하고 있는 Django 프레임워크와 Flask 프레임워크에서는 각각 Django 템플릿과\nJinja2 템플릿을 사용할 시 XSS 공격에 악용될 수 있는 위험한 HTML 문자들을 HTML 특수문자 (HTML\nEntities)로 치환하는 기능을 제공하고 있어 프레임워크에서 제공하는 템플릿을 사용하는 경우 위협을 최소화\n할 수 있다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "외부 입력값 또는 출력값에 스크립트가 삽입되지 못하도록 문자열 치환 함수를 사용하여 &<>*‘/() 등을",
        "&amp; &lt; &gt; &quot; &#x27; &#x2F; &#x28; &#x29;로 치환하거나, html라이브러리의 escape()를",
        "사용해 문자열을 변환해야 한다. HTML 태그를 허용해야 하는 게시판에서는 허용할 HTML 태그들을 화이트",
        "리스트로 만들어 해당 태그만 지원하도록 한다.",
        "파이썬에서 가장 많이 사용하는 프레임워크인 Django, Flask 등을 사용하는 경우 외부 입력값에 악의적인",
        "스크립트가 삽입되지 못하도록 프레임워크 자체에서 XSS 공격에 사용될 수 있는 문자를 HTML 특수문자",
        "(HTML Entities)로 치환하여 응답 페이지를 생성하므로 XSS 공격으로부터 안전하다.",
        "Python 시큐어코딩 가이드",
        "안전한 코드 예시",
        "1: from django.shortcuts import render",
        "2:",
        "3: def profile_link(request):",
        "4: # 외부 입력값을 검증 없이 HTML 태그 생성의 인자로 사용",
        "5: profile_url = request.POST.get('profile_url')",
        "6: profile_name = requst.POST.get('profile_name')",
        "7:",
        "8: object_link = '<a href=\"{}\">{}</a>'.format(profile_url, profile_name)",
        "9: # 신뢰할 수 없는 데이터에 대해서는 mark_safe 함수를 사용해선 안 된다",
        "10:",
        "11: return render(request, 'my_profile.html',{'object_link':object_link})",
        "다음은 또 다른 Django 프레임워크 템플릿 예제를 보여 준다. autoescape 블록 사용 시 설정값을 off로",
        "할 경우와 개별 변수에 대해서 safe 필터를 사용할 경우 크로스사이트 스크립트 공격에 노출될 수 있다.",
        "안전하지 않은 코드 예시",
        "1: <!doctype html>",
        "2: <html>",
        "3: <body>",
        "4: <div class=\"content\">",
        "5: {% autoescape off %}",
        "6: <!-- autoescape off로 설정하면 해당 블록내의 데이터는 XSS 공격에",
        "7: 노출될 수 있다 -->",
        "8: {{ content }}",
        "9: {% endautoescape %}",
        "10: </div>",
        "11: <div class=\"content2\">",
        "12: <!-- safe 필터 사용으로 XSS 공격에 노출될 수 있다 -->",
        "13: {{ content | safe }}",
        "14: </div>",
        "15: </body>",
        "16: </html>",
        "신뢰할 수 없는 입력값 또는 동적 데이터에 대해서는 autoescape 옵션 값을 on으로 설정해야 하며, safe",
        "필터를 부득이 하게 사용할 경우에는 추가적인 보안대책이 필요하다.",
        "Python 시큐어코딩 가이드",
        "동적 웹 페이지 생성에 사용하는 데이터를 HTML 엔티티 코드 (Entity Code)로 치환하여 안전하게 표현해야",
        "한다. html.escape 메소드는 문자열의 &, < 및 > 특수문자를 HTML에서 안전한 값으로 변환한다. quote",
        "옵션 값이 True이면 문자 (“)와 (‘)도 변환된다. <a href=”…“>에서처럼 따옴표로 구분된 HTML 속성",
        "(attribute) 값이 들어간 문자열을 포함할 경우에도 사용할 수 있다.",
        "안전한 코드 예시",
        "1: import html",
        "2: from flask import Flask, request, render_template",
        "3:",
        "4: @app.route('/search', methods=['POST'])",
        "5: def search():",
        "6: search_keyword = request.form.get('search_keyword')",
        "7:",
        "8: # 동적 웹페이지 생성에 사용되는 데이터는",
        "9: # HTML 엔티티코드로 치환하여 표현해야 한다",
        "10: escape_keyword = html.escape(search_keyword)",
        "11: return render_template('search.html', search_keyword=escape_keyword)",
        "라. 참고자료",
        "① CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'), MITRE,",
        "https://cwe.mitre.org/data/definitions/79.html",
        "② Cross Site Scripting (XSS), OWASP,",
        "https://owasp.org/www-community/attacks/xss/",
        "③ html - HyperText Markup Language support, Python Software Foundation,",
        "https://docs.python.org/3/library/html.html",
        "④ Flask Security Considerations Cross-Site Scripting (XSS), Flask docs,",
        "https://flask-docs-kr.readthedocs.io/ko/latest/security.html",
        "⑤ Django Security in Django Cross site scripting (XSS) protection, Django Software Foundation,",
        "https://docs.djangoproject.com/en/3.2/topics/security/"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 5,
      "korean_name": "운영체제 명령어 삽입",
      "english_type": "Command_Injection",
      "start_page": 29,
      "end_page": 32,
      "description": "",
      "unsafe_codes": [
        {
          "code": "다음 예제는 os.system을 이용해 외부로부터 받은 입력값을 통해 프로그램을 실행하며, 외부에서 전달되는\n인자값은 명령어의 생성에 사용된다. 하지만 해당 프로그램에서 실행할 프로그램을 제한하지 않고 있기 때문에\n외부의 공격자는 원하는 모든 프로그램을 실행할 수 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: import os\n2: from django.shortcuts import render\n3:\n4: def execute_command(request):\n5: app_name_string = request.POST.get('app_name','')\n6: # 입력 파라미터를 제한하지 않아 외부 입력값으로 전달된\n7: # 모든 프로그램이 실행될 수 있음\n8: os.system(app_name_string)\n9: return render(request, '/success.html')\n외부에서 입력받은 값이 명령어의 인자로 사용되지 않고 명령어 그 자체로 사용될 경우에는 사전에 화이트\n리스트 파라미터 배열을 정의한 후 외부의 입력에 따라 적절한 파라미터를 선택하도록 하여 외부의 부적절한\n입력이 명령어로 사용되는 것을 금지해야 한다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: import os\n2: from django.shortcuts import render\n3:\n4: ALLOW_PROGRAM = ['notepad', 'calc']\n5:\n6: def execute_command(request):\n7: app_name_string = request.POST.get('app_name','')\n8:\n9: # 입력받은 파라미터가 허용된 시스템 명령어 목록에 포함되는지 검사\n10: if app_name_string not in ALLOW_PROGRAM:\n11: return render(request, '/error.html', {'error':'허용되지 않은 프로그램입니다.'})\n12:\n13: os.system(app_name_string)\n14: return render(request, '/success.html')\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전한 코드 예시"
        },
        {
          "code": "1: import subprocess\n2: from django.shortcuts import render\n3:\n4: def execute_command(request):\n5: date = request.POST.get('date','')\n6:\n7: # 명령어를 추가로 실행 또는 또 다른 명령이 실행될 수 있는 키워드에\n8: # 대한 예외처리\n9: for word in ['|', ';', '&', ':', '>', '<', '`', '\\\\', '!']:\n10: date = date.replace(word, “”)\n11: # re.sub 함수를 사용해 특수문자를 제거하는 방법도 있다\n12: # date = re.sub('[|;&:><`\\\\\\!]', '', date)\n13:\n14: # shell=True 옵션은 제거 하고 명령과 인자를 배열로 입력\n15: subprocess.run([\"cmd\", \"/c\", \"backuplog.bat\", date])\n16: return render(request, '/success.html')",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 6,
      "korean_name": "위험한 형식 파일 업로드",
      "english_type": "File_Upload",
      "start_page": 33,
      "end_page": 35,
      "description": "",
      "unsafe_codes": [
        {
          "code": "업로드 대상 파일 개수, 크기, 확장자 등의 유효성 검사를 하지 않고 파일 시스템에 그대로 저장할 경우\n공격자에 의해 악성코드, 쉘코드 등 위험한 형식의 파일이 시스템에 업로드 될 수 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from django.shortcuts import render\n2: from django.core.files.storage import FileSystemStorage\n3:\n4: def file_upload(request):\n5: if request.FILES['upload_file']:\n6: # 사용자가 업로드하는 파일을 검증 없이 저장하고 있어\n7: # 안전하지 않다\n8: upload_file = request.FILES['upload_file']\n9: fs = FileSystemStorage(location='media/screenshot', base_url='media/screenshot')\n10: # 업로드 하는 파일에 대한 크기, 개수, 확장자 등을 검증하지 않음\n11: filename = fs.save(upload_file.name, upload_file)\n12: return render(request, '/success.html', {'filename':filename})\n13: return render(request, '/error.html', {'error':'파일 업로드 실패'})\n아래 코드는 업로드 하는 파일의 개수, 크기, 파일 확장자 등을 검사해 업로드를 제한하고 있다. 파일 타입\n확인은 MIME 타입을 확인하는 과정으로 파일 이름에서 확장자만 검사할 경우 변조된 확장자를 통해 업로드\n제한을 회피할 수 있어 파일자체의 시그니처를 확인하는 과정을 보여 준다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: import os\n2: from django.shortcuts import render\n3: from django.core.files.storage import FileSystemStorage\n4:\n5: # 업로드 하는 파일 개수, 크기, 확장자 제한\n6: FILE_COUNT_LIMIT = 5\n7: # 업로드 하는 파일의 최대 사이즈 제한 예 ) 5MB - 5*1024*1024\n8: FILE_SIZE_LIMIT = 5242880\n9: # 허용하는 확장자는 화이트리스트로 관리한다.\n10: WHITE_LIST_EXT = [\n11: '.jpg',\n12: '.jpeg'\n13: ]",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 7,
      "korean_name": "신뢰되지 않은 URL주소로 자동접속 연결",
      "english_type": "Open_Redirect",
      "start_page": 36,
      "end_page": 38,
      "description": "사용자가 입력하는 값을 외부 사이트 주소로 사용해 해당 사이트로 자동 접속하는 서버 프로그램은 피싱\n(Phishing) 공격에 노출되는 취약점을 가진다. 클라이언트에서 전송된 URL 주소로 연결하기 때문에 안전하다고\n생각할 수 있으나, 공격자는 정상적인 폼 요청을 변조해 사용자가 위험한 URL로 접속할 수 있도록 공격할 수 있다.\n파이썬 프레임워크의 redirect 함수를 사용할 때에도 해당 프레임워크 버전에서 알려진 취약점이 있는지\n확인해야 한다. Flask 프레임워크의 Flask-Security-Too 라이브러리의 경우 get_post_logout_redirect 함수와\nget_post_login_redirect 함수가 4.1.0 이전 버전에서 URL 유효성 검사를 우회하고 사용자를 임의의 URL로\n리다이렉션 할 수 있는 취약점이 존재한다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "리다이렉션을 허용하는 모든 URL을 서버 측 화이트리스트로 관리하고 사용자 입력값을 리다이렉션 할",
        "URL이 존재하는지 검증해야 한다.",
        "만약 사용자 입력값이 화이트리스트로 관리가 불가능하고 리다이렉션 URL의 인자 값으로 사용되어야만 하는",
        "경우는 모든 리다이렉션에서 프로토콜과 host 정보가 들어가지 않는 상대 URL(relative)을 사용 및 검증해야",
        "한다. 또는 절대 URL(absoute URL)을 사용할 경우 리다이렉션을 실행하기 전에 사용자 입력 URL이",
        "https://myhompage.com/ 처럼 서비스하고 있는 URL로 시작하는지를 확인해야 한다.",
        "Python 시큐어코딩 가이드",
        "라. 참고자료",
        "① CWE-601: URL Redirection to Untrusted Site ('Open Redirect'), MITRE,",
        "https://cwe.mitre.org/data/definitions/601.html",
        "② Unvalidated Redirects and Forwards Cheat Sheet, OWASP",
        "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html",
        "③ Django shortcut functions – redirect, Django Sowftware Foundation,",
        "https://docs.djangoproject.com/en/3.2/topics/http/shortcuts/",
        "④ Redirects and Errors, Flask,",
        "https://flask.palletsprojects.com/en/2.0.x/quickstart/#redirects-and-errors"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 8,
      "korean_name": "부적절한 XML 외부 개체 참조",
      "english_type": "XXE",
      "start_page": 39,
      "end_page": 41,
      "description": "",
      "unsafe_codes": [
        {
          "code": "다음 예제는 XML 소스를 읽어와 분석하는 코드다. 공격자는 아래와 같이 XML 외부 엔티티를 참조하는\nxxe.xml 데이터를 전송하고 이를 파싱할 때 /etc/passwd 파일을 참조할 수 있다.\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe1 SYSTEM \"file:///etc/passwd\" >\n<!ENTITY xxe2 SYSTEM \"http://attacker.com/text.txt\">\n]>\n<foo>&xxe1;&xxe2;</foo>",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from xml.sax import make_parser\n2: from xml.sax.handler import feature_external_ges\n3: from xml.dom.pulldom import parseString, START_ELEMENT\n4: from django.shortcuts import render\n5: from .model import comments\n6:\n7: def get_xml(request):\n8: if request.method == “GET”:\n9: data = comments.objects.all()\n10: com = data[0].comment\n11: return render(request, '/xml_view.html', {'com':com})\n12:\n13: elif request.method == “POST”:\n14: parser = make_parser()\n15: # 외부 일반 엔티티를 포함하는 설정을 True로 적용할 경우 취약하다\n16: parser.setFeature(feature_external_ges, True)\n17: doc = parseString(request.body.decode(‘utf-8’), parser=parser)\n18: for event, node in doc:\n19: if event == START_ELEMENT and node.tagName == “foo”:\n20: doc.expandNode(node)\n21: text = node.toxml()\n22: comments.objects.filter(id=1).update(comment=text)\n23: return render(request, '/xml_view.html')",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 9,
      "korean_name": "XML 삽입",
      "english_type": "XML_Injection",
      "start_page": 42,
      "end_page": 43,
      "description": "검증되지 않은 외부 입력값이 XQuery 또는 XPath 쿼리문을 생성하는 문자열로 사용되어 공격자가 쿼리문의\n구조를 임의로 변경하고 임의의 쿼리를 실행해 허가되지 않은 데이터를 열람하거나 인증절차를 우회할 수 있는\n보안약점이다.",
      "unsafe_codes": [
        {
          "code": "다음 예제는 파이썬에서 XML 데이터를 처리하기 위한 기본 모듈인 xml.etree.ElementTree를 이용하여\n사용자 정보를 가져오는 예제다. xml.etree.ElementTree 모듈은 제한적인 Xpath 기능을 제공하며 Xpath\n표현식을 인자화해서 사용하는 방법을 제공하지 않는다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from django.shortcuts import render\n2: from lxml import etree\n3:\n4: def parse_xml(request):\n5: user_name = request.POST.get('user_name', '')\n6:\n7: parser = etree.XMLParser(resolve_entities=False)\n8: tree = etree.parse('user.xml', parser)\n9: root = tree.getroot()\n10:\n11: # 검증되지 않은 외부 입력값 user_name을 사용한 안전하지 않은\n12: # 질의문이 query 변수에 저장\n13: query = \"/collection/users/user[@name='\" + user_name + \"']/home/text()\"\n14: elmts = root.xpath(query)\n15: return render(request, 'parse_xml.html', {'xml_element':elmts})",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "XQuery 또는 XPath 쿼리에 사용되는 외부 입력 데이터에 대하여 특수문자 및 쿼리 예약어를 필터링 하고",
        "인자화된 쿼리문을 지원하는 XQuery를 사용해야 한다."
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 10,
      "korean_name": "LDAP 삽입",
      "english_type": "LDAP_Injection",
      "start_page": 44,
      "end_page": 47,
      "description": "외부 입력값을 적절한 처리 없이 LDAP 쿼리문이나 결과의 일부로 사용하는 경우 LDAP 쿼리문이 실행될 때\n공격자는 LDAP 쿼리문의 내용을 마음대로 변경할 수 있다. 이로 인해 프로세스가 명령을 실행한 컴포넌트와\n동일한 권한(Permission)을 가지고 동작하게 된다.\n파이썬에는 파이썬-ldap 및 ldap3라는 두 개의 라이브러리가 있다. ldap3가 python-ldap 보다 더 현대적인\n라이브러리다. ldap3 모듈은 파이썬 2.6부터 모든 파이썬 3 버전에 호환된다. ldap3에서는 좀 더 파이썬적인\n방식으로 LDAP서버와 상호 작용할 수 있는 완전한 기능의 추상화 계층이 포함되어 있다. python-ldap은\nOpenLDAP에서 만든 파이썬2의 패키지로 파이썬3에서는 ldap3 라이브러리를 사용하는 것이 권장된다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "다른 삽입 공격들과 마찬가지로 LDAP 삽입에 대한 기본적인 방어 방법은 적절한 유효성 검사이다.",
        "⦁올바른 인코딩(Encoding) 함수를 사용해 모든 변수 이스케이프(Escape) 처리",
        "⦁화이트리스트 방식의 입력값 유효성 검사",
        "⦁사용자 패스워드와 같은 민감한 정보가 포함된 필드 인덱싱",
        "⦁LDAP 바인딩 계정에 할당된 권한 최소화",
        "Python 시큐어코딩 가이드",
        "사용자의 입력 중 LDAP 질의문에 사용될 변수를 이스케이프 하여 질의문 실행 시 공격에 노출되는 것을",
        "예방할 수 있다.",
        "안전한 코드 예시",
        "1: from ldap3 import Connection, Server, ALL",
        "2: from ldap3.utils.conv import escape_filter_chars",
        "3: from django.shortcuts import render",
        "4:",
        "5: config = {",
        "6: \"bind_dn\": \"cn=read-only-admin,dc=example,dc=com\",",
        "7: \"password\": \"password\",",
        "8: }",
        "9:",
        "10: def ldap_query(request):",
        "11: search_keyword = request.POST.get('search_keyword','')",
        "12:",
        "13: dn = config['bind_dn']",
        "14: password = config['password']",
        "15: address = 'ldap.goodsource.com'",
        "16: server = Server(address, get_info=ALL)",
        "17: conn = Connection(server, dn, password, auto_bind=True )",
        "19:",
        "20: # 사용자의 입력에 필터링을 적용하여 공격에 사용될 수 있는 문자를",
        "21: # 이스케이프하고 있다",
        "22: escpae_keyword = escape_filter_chars(search_keyword)",
        "23: search_str = '(&(objectclass=%s))' % escpae_keyword",
        "24:",
        "25: conn.search(",
        "26: 'dc=company,dc=com',",
        "27: search_str,",
        "28: attributes=['sn', 'cn', 'address', 'mail', 'mobile', 'uid'],",
        "29: )",
        "30:",
        "31: return render(request, '/ldap_query_response.html', {'ldap':conn.entries})"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 11,
      "korean_name": "크로스사이트 요청 위조(CSRF)",
      "english_type": "CSRF",
      "start_page": 48,
      "end_page": 54,
      "description": "특정 웹사이트에 대해 사용자가 인지하지 못한 상황에서 사용자의 의도와는 무관하게 공격자가 의도한 행위\n(수정, 삭제, 등록 등)를 요청하게 하는 공격을 말한다. 웹 응용프로그램이 사용자로부터 받은 요청이 해당 사용자가\n의도한 대로 작성되고 전송된 것인지 확인하지 않는 경우 발생 가능하다. 특히 사용자가 관리자 권한을 가지는\n경우 사용자 권한관리, 게시물 삭제, 사용자 등록 등 관리자 권한으로만 수행 가능한 기능을 공격자의 의도대로\n실행시킬 수 있게 된다. 공격자는 사용자가 인증한 세션이 특정 동작을 수행해도 계속 유지되어 정상적인 요청과\n비정상적인 요청을 구분하지 못하는 점을 악용한다.\n파이썬에서 가장 많이 사용하고 있는 Django 프레임워크와 Flask 프레임워크에서는 각각 CSRF(Cross-Site\nRequest Forgery) 토큰 기능을 지원하고 있으며, Django는 {% csrf token %} 태그를 이용해 CSRF 토큰\n기능 제공하고 Flask에서는 Flask-WTF 확장 라이브러리를 통해 {{form.csrf_token}} 태그를 이용한 CSRF\n토큰 기능을 제공해 태그를 사용하는 경우 CSRF 공격에 대비할 수 있다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "해당 요청이 정상적인 사용자의 정상적인 절차에 의한 요청인지를 구분하기 위해 세션별로 CSRF 토큰을",
        "생성하여 세션에 저장하고 사용자가 작업 페이지를 요청할 때마다 hidden 값으로 클라이언트에게 토큰을 전달한 뒤,",
        "해당 클라이언트의 데이터 처리 요청 시 전달되는 CSRF 토큰값을 체크하여 요청의 유효성을 검사하도록 한다.",
        "Python 시큐어코딩 가이드",
        "안전한 코드 예시",
        "1: MIDDLEWARE = [",
        "2: 'django.contrib.sessions.middleware.SessionMiddleware',",
        "3: # MIDDLEWARE 목록에서 CSRF 항목을 활성화 한다",
        "4: 'django.middleware.csrf.CsrfViewMiddleware',",
        "5: 'django.contrib.auth.middleware.AuthenticationMiddleware',",
        "6: 'django.contrib.messages.middleware.MessageMiddleware',",
        "7: 'django.middleware.locale.LocaleMiddleware',",
        "8: ......",
        "9: ]",
        "⦁Django 뷰 기능 설정(views.py) 사례",
        "미들웨어에 CSRF 검증 기능이 활성화 되어 있어도 View에서 CSRF 기능을 해제하는 경우에는 해당 요청에",
        "대해서 CSRF 검증 기능을 사용하지 않게 된다. 다음은 Function-Based View에서 CSRF 검증 기능을 비활성화",
        "하는 예제를 보여 준다.",
        "안전하지 않은 코드 예시",
        "1: from django.shortcuts import render",
        "2: from django.views.decorators.csrf import csrf_exempt",
        "3:",
        "4: # csrf.exempt 데코레이터로 미들웨어에서 보호되는 CSRF 기능을 해제한다",
        "5: @csrf.exempt",
        "6: def pay_to_point(request):",
        "7: user_id = request.POST.get('user_id', '')",
        "8: pay = request.POST.get('pay', '')",
        "9: product_info = request.POST.get('product_info', '')",
        "10:",
        "11: ret = handle_pay(user_id, pay, product_info)",
        "12:",
        "13: return render(request, '/view_wallet.html', {'wallet':ret})",
        "Python 시큐어코딩 가이드",
        "미들웨어에서 CSRF 기능을 활성화한 후에 템플릿 페이지에서는 csrf_token 값을 명시하여야만 정상적인",
        "CSRF 검증 기능을 사용할 수 있다.",
        "안전한 코드 예시",
        "1: <!--html page-->",
        "2: <form action=\"\" method=\"POST\">",
        "3: {% csrf_token %} <!--csrf_token 사용->",
        "4: <table>",
        "5: {{form.as_table}}",
        "6: </table>",
        "7: <input type=\"submit\"/>",
        "8: </form>",
        "나) Flask 프레임워크 사용",
        "⦁Flask app 설정 사례",
        "Flask의 WTF 패키지를 사용하면 CSRF 보호 기법을 사용할 수 있다. 아래 예제 코드는 CSRF 설정이 되지",
        "않은 상태를 보여 준다.",
        "안전하지 않은 코드 예시",
        "1: from flask import Flask",
        "2:",
        "3: app = Flask(__name__)",
        "Flask 프레임워크를 사용해 웹 애플리케이션을 구축하는 경우 CSRF를 방지하려면 Flask-WTF extension의",
        "CSRFProtect를 사용해야 한다. 다음과 같이 app에 설정하고 HTML(템플릿) 페이지에는 CSRF 토큰을 추가",
        "해야 한다.",
        "Python 시큐어코딩 가이드",
        "안전한 코드 예시",
        "1: <form action=\"\" method=\"POST\">",
        "2: <!-- form 태그 내부에 csrf_token 적용-->",
        "3: <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\" />",
        "4: <table>",
        "5: {{table}}",
        "6: </table>",
        "7: <input type=\"submit\"/>",
        "8: </form>",
        "라. 참고자료",
        "① CWE-352: Cross-Site Request Forgery (CSRF), MITRE,",
        "https://cwe.mitre.org/data/definitions/352.html",
        "② Cross Site Request Forgery (CSRF), OWASP,",
        "https://owasp.org/www-community/attacks/csrf",
        "③ Cross-Site Request Forgery Prevention Cheat Sheet, OWASP",
        "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html",
        "④ Cross Site Request Forgery protection, Django Software Foundation",
        "https://docs.djangoproject.com/en/3.2/ref/csrf/",
        "⑤ CSRF Protection, WTForms",
        "https://flask-wtf.readthedocs.io/en/0.15.x/csrf/"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 12,
      "korean_name": "서버사이드 요청 위조",
      "english_type": "SSRF",
      "start_page": 55,
      "end_page": 57,
      "description": "",
      "unsafe_codes": [
        {
          "code": "<참고 : 삽입 코드의 예>\n설명 삽입 코드의 예\n내부망 중요 정보 획득 http://sample_site.com/connect?url=http://192.168.0.45/member/list.json\n외부 접근 차단된\nhttp://sample_site.com/connect?url=http://192.168.0.45/admin\nadmin 페이지 접근\n도메인 체크를 우회하여 http://sample_site.com/connect?url=http://sample_site.com:x@192.168.0.45/member/\n중요 정보 획득 list.json\n단축 URL을 이용한\nhttp://sample_site.com/connect?url=http://bit.ly/sdjk3kjhkl3\nFilter 우회\n도메인을 사설IP로 설정해\nhttp://sample_site.com/connect?url=http://192.168.0.45/member/list.json\n중요정보 획득\n서버내 파일 열람 http://sample_site.com/connect?url=file:///etc/passwd\n다음 예제는 안전하지 않은 코드를 보여 준다. 사용자로부터 입력된 URL 주소를 검증 없이 사용하면 의도하지\n않은 다른 서버의 자원에 접근할 수 있게 된다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from django.shortcuts import render\n2: import requests\n3:\n4: def call_third_party_api(request):\n5: addr = request.POST.get('address', '')\n6:\n7: # 사용자가 입력한 주소를 검증하지 않고 HTTP 요청을 보낸 후\n8: # 응답을 사용자에게 반환\n9: result = requests.get(addr).text\n10: return render(request, '/result.html', {'result':result})\n다음과 같이 안전한 코드를 작성하면 사전에 정의된 서버 목록을 정의하고 매칭되는 URL만 사용할 수 있으므로\nURL 값을 임의로 조작할 수 없다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 13,
      "korean_name": "HTTP 응답분할",
      "english_type": "HTTP_Response_Splitting",
      "start_page": 58,
      "end_page": 60,
      "description": "HTTP 요청 내의 파라미터(Parameter)가 HTTP 응답 헤더에 포함되어 사용자에게 다시 전달될 때 입력값에\nCR(Carriage Return)이나 LF(Line Feed)와 같은 개행문자가 존재하면 HTTP 응답이 2개 이상으로 분리될\n수 있다. 이 경우 공격자는 개행문자를 이용해 첫 번째 응답을 종료 시키고 두 번째 응답에 악의적인 코드를\n주입해 XSS 및 캐시훼손(Cache Poisoning) 공격 등을 수행할 수 있다.\n파이썬 3.9.5+ 버전에서의 URLValidator에서 HTTP 응답분할 취약점이 보고되기도 했고 해당 라이브러리를\n사용하는 Django버전에도 영향이 있다. HTTP 응답분할 공격으로부터 어플리케이션을 안전하게 지키려면 최신\n버전의 라이브러리, 프레임워크를 사용하고 외부 입력값에 대해서는 철저한 검증 작업을 수행해야 한다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "요청 파라미터의 값을 HTTP 응답 헤더(예를 들어, Set-Cookie 등)에 포함시킬 경우 CR(\\r), LF(\\n)와",
        "같은 개행문자를 제거해야 한다. 외부 입력값이 헤더, 쿠키, 로그 등에 사용될 경우에는 항상 개행문자를 검증",
        "하고 가능하다면 헤더에 사용되는 예약어 등을 화이트리스트로 제한해야 한다.",
        "Python 시큐어코딩 가이드",
        "라. 참고자료",
        "① CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting'), MITRE,",
        "https://cwe.mitre.org/data/definitions/113.html",
        "② HTTP Response Splitting, OWASP,",
        "https://owasp.org/www-community/attacks/HTTP_Response_Splitting",
        "③ Django security releases issued, Django Software Foundation,",
        "https://www.djangoproject.com/weblog/2021/may/06/security-releases/"
      ]
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 14,
      "korean_name": "정수형 오버플로우",
      "english_type": "Integer_Overflow",
      "start_page": 61,
      "end_page": 63,
      "description": "",
      "unsafe_codes": [
        {
          "code": "다음은 거듭제곱을 계산해 그 결과를 반환하는 함수 예시로, 계산 가능한 숫자에 대한 검증이 없어 에러는\n발생하지 않지만 반환값을 처리하는 함수에서 예기치 않은 오류가 발생할 수 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: import numpy as np\n2:\n3: def handle_data(number, pow):\n4: res = np.power(number, pow, dtype=np.int64)\n5: # 64비트를 넘어서는 숫자와 지수가 입력될 경우 오버플로우가 발생해 결과값이 0이 된다\n6: return res\n오버플로우 발생을 예방하려면 입력하는 값이 사용하는 데이터 타입의 최소보다 크거나 최대보다 작은지\n확인해야 한다. 만약 위 코드 예시처럼 값을 계산해야 하는 경우 오버플로우가 발생하지 않는 파이썬 기본 자료형에\n계산 결과값을 저장한 후 그 값을 검사해 오버플로우 여부를 확인해야 한다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: import numpy as np\n2:\n3: MAX_NUMBER = np.iinfo(np.int64).max\n4: MIN_NUMBER = np.iinfo(np.int64).min\n5:\n6: def handle_data(number, pow):\n7:\n8: calculated = number ** pow\n9: # 파이썬 기본 자료형으로 큰 수를 계산한 후 이를 검사해 오버플로우 탐지\n10: if calculated > MAX_NUMBER or calculated < MIN_NUMBER:\n11: # 오버플로우 탐지 시 비정상 종료를 나타내는 –1 값 반환\n12: return –1\n13:\n14: res = np.power(number, pow, dtype=np.int64)\n15: return res",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 15,
      "korean_name": "보안기능 결정에 사용되는 부적절한 입력값",
      "english_type": "Input_Validation",
      "start_page": 64,
      "end_page": 66,
      "description": "응용 프로그램이 외부 입력값에 대한 신뢰를 전제로 보호 메커니즘을 사용하는 경우 공격자가 입력값을 조작\n할 수 있다면 보호 메커니즘을 우회할 수 있게 된다.\n개발자들이 흔히 쿠키, 환경변수 또는 히든필드와 같은 입력값이 조작될 수 없다고 가정하지만 공격자는 다양한\n방법을 통해 이러한 입력값들을 변경할 수 있고 조작된 내용은 탐지되지 않을 수 있다. 인증이나 인가와 같은\n보안 결정이 이런 입력값(쿠키, 환경변수, 히든필드 등)에 기반을 두어 수행되는 경우 공격자는 입력값을 조작해\n응용프로그램의 보안을 우회할 수 있다. 따라서 충분한 암호화, 무결성 체크를 수행하고 이와 같은 메커니즘이\n없는 경우엔 외부 사용자에 의한 입력값을 신뢰해서는 안 된다.\n파이썬의 Django 프레임워크에서 세션을 관리하는 기능을 제공하고 있으며, 해당 기능 사용 시에는 세션쿠키의\n만료 시점을 설정해 사용할 수 있으며 DRF(Django Rest Framework)에서 제공하는 토큰 및 세션 기능을\n사용해 안전하게 구성할 수 있다.\n\n\n\nPython 시큐어코딩 가이드\n중요 기능 수행을 위한 데이터는 위변조 가능성이 높은 쿠키보다 세션에 저장하도록 한다.\n안전한 코드 예시\n1: from django.shortcuts import render\n2:\n3: def init_password(request):\n4: # 세션에서 권한 정보를 가져옴\n5: role = request.session['role']\n6: request_id = request.POST.get('user_id', '')\n7: request_mail = request.POST.get('user_email','')\n8: # 세션에서 가져온 권한이 관리자인지 비교\n9: if role == ‘admin’:\n10: # 사용자의 패스워드 초기화 및 메일 발송 처리\n11: password_init_and_sendmail(request_id, request_mail)\n12: return render(request, '/sucess.html')\n13: else:\n14: return render(request, '/failed.html')\n라. 참고자료\n① CWE-807: Reliance on Untrusted Inputs in a Security Decision, MITRE,\nhttps://cwe.mitre.org/data/definitions/807.html\n② How to use sessions, Django Software Foundation,\nhttps://docs.djangoproject.com/en/3.2/topics/http/sessions/\n③ Flask Sessions,\nhttps://flask-session.readthedocs.io/en/latest/",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제1절 입력데이터 검증 및 표현",
      "number": 16,
      "korean_name": "포맷 스트링 삽입",
      "english_type": "Format_String",
      "start_page": 67,
      "end_page": 68,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 1,
      "korean_name": "적절한 인증 없는 중요 기능 허용",
      "english_type": "Missing_Authentication",
      "start_page": 69,
      "end_page": 71,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 2,
      "korean_name": "부적절한 인가",
      "english_type": "Improper_Authorization",
      "start_page": 72,
      "end_page": 74,
      "description": "프로그램이 모든 가능한 실행 경로에 대해서 접근 제어를 검사하지 않거나 불완전하게 검사하는 경우 공격자는\n접근 가능한 실행경로를 통해 정보를 유출할 수 있다.",
      "unsafe_codes": [
        {
          "code": "사용자 입력값에 따라 삭제 작업을 수행하고 있으며 사용자의 권한 확인을 위한 별도의 통제가 적용되지\n않은 예시를 보여 준다.\n3)\u0000공격자가\u0000진입\u0000또는\u0000영향을\u0000줄\u0000수\u0000있는\u0000시스템\u0000경계선\u0000지점,\u0000시스템\u0000요소\u0000또는\u0000환경을\u0000의미(https://csrc.nist.g\nov/glossary/term/attack_surface)\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "응용 프로그램이 제공하는 정보와 기능이 가지는 역할에 맞게 분리 개발함으로써 공격자에게 노출되는 공격",
        "노출면(Attack Surface)3)을 최소화하고 사용자의 권한에 따른 ACL(Access Control List)을 관리한다."
      ]
    },
    {
      "section": "제2절 보안기능",
      "number": 3,
      "korean_name": "중요한 자원에 대한 잘못된 권한 설정",
      "english_type": "Incorrect_Permission",
      "start_page": 75,
      "end_page": 76,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 4,
      "korean_name": "취약한 암호화 알고리즘 사용",
      "english_type": "Weak_Cryptography",
      "start_page": 77,
      "end_page": 80,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 5,
      "korean_name": "암호화되지 않은 중요정보",
      "english_type": "Unencrypted_Data",
      "start_page": 81,
      "end_page": 84,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 6,
      "korean_name": "하드코드된 중요정보",
      "english_type": "Hardcoded_Secrets",
      "start_page": 85,
      "end_page": 87,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 7,
      "korean_name": "충분하지 않은 키 길이 사용",
      "english_type": "Insufficient_Key_Length",
      "start_page": 88,
      "end_page": 90,
      "description": "짧은 길이의 키를 사용하는 것은 암호화 알고리즘을 취약하게 만들 수 있다. 키는 암호화 및 복호화에 사용\n되는데, 검증된 암호화 알고리즘을 사용하더라도 키 길이가 충분히 길지 않으면 짧은 시간 안에 키를 찾아낼\n수 있고 이를 이용해 공격자가 암호화된 데이터나 패스워드를 복호화 할 수 있게 된다.\n암호 알고리즘 및 키 길이 선택 시 암호 알고리즘의 안전성 유지기간과 보안강도별 암호 알고리즘 키 길이\n비교표를 기반으로 암호 알고리즘 및 키 길이를 선택해야 한다.\n< 보안강도별 암호 알고리즘 비교표 >\n대칭키 암호 공개키 암호 알고리즘 암호 알고리즘\n해시함수\n보안강도 알고리즘 (보안강도) 인수분해 이산대수 타원곡선 안전성 유지기간\n(보안강도) (년도)\n(비트) 공개키(비트) 개인키(비트) 암호(비트)\n2011년에서\n112 비트 112 112 2048 2048 224 224\n2030년까지\n128 비트 128 128 3072 3072 256 256\n192 비트 192 192 7680 7680 384 384 2030년 이후\n256비트 256 256 15360 15360 512 512\n\n\n\nPython 시큐어코딩 가이드\n안전한 코드 예시\n1: from Crypto.PublicKey import RSA, DSA, ECC\n2: from tinyec import registry\n3: import secrets\n4:\n5: def make_rsa_key_pair():\n6: # RSA 키 길이를 2048 비트 이상으로 길게 설정\n7: private_key = RSA.generate(2048)\n8: public_key = private_key.publickey()\n9:\n10: def make_ecc():\n11: # ECC 키 길이를 224 비트 이상으로 설정\n12: ecc_curve = registry.get_curve('secp224r1')\n13: private_key = secrets.randbelow(ecc_curve.field.n)\n14: public_key = private_key * ecc_curve.g\n라. 참고자료\n① CWE-326: Inadequate Encryption Strength, MITRE,\nhttps://cwe.mitre.org/data/definitions/326.html\n② FEDERAL INFORMATION PROCESSING STANDARDS PUBLICATION (FIPS PUB 186-4), NIST\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n③ PyCryptodome-RSA,\nhttps://pycryptodome.readthedocs.io/en/latest/src/public_key/rsa.html\n④ 암호 알고리즘 및 키 길이 이용 안내서, KISA,\nhttps://www.kisa.or.kr/2060305/form?postSeq=5&lang_type=KO#fnPostAttachDownload\n⑤ DSA, Pycryptodome,\nhttps://pycryptodome.readthedocs.io/en/latest/src/public_key/dsa.html\n⑥ ECC, Pycryptodome,\nhttps://pycryptodome.readthedocs.io/en/latest/src/public_key/ecc.html",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 8,
      "korean_name": "적절하지 않은 난수 값 사용",
      "english_type": "Weak_Random",
      "start_page": 91,
      "end_page": 93,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 9,
      "korean_name": "취약한 패스워드 허용",
      "english_type": "Weak_Password",
      "start_page": 94,
      "end_page": 97,
      "description": "사용자에게 강한 패스워드 조합규칙을 요구하지 않으면 사용자 계정이 취약하게 된다. 안전한 패스워드를\n생성하기 위해서는 「패스워드 선택 및 이용 안내서」에서 제시하는 패스워드 설정 규칙을 적용해야 한다.",
      "unsafe_codes": [
        {
          "code": "사용자가 입력한 패스워드에 대한 복잡도 검증 없이 가입 승인 처리를 수행하고 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from flask import request, redirect\n2: from Models import User\n3: from Models import db\n4:\n5: @app.route('/register', methods=['POST'])\n6: def register():\n7: userid = request.form.get('userid')\n8: password = request.form.get('password')\n9: confirm_password = request.form.get('confirm_password')\n10:\n11: if password != confirm_password:\n12: return make_response(\"패스워드가 일치하지 않습니다\", 400)\n13: else:\n14: usertable = User()\n15: usertable.userid = userid\n16: usertable.password = password\n17: # 패스워드 생성 규칙을 확인하지 않고 회원 가입\n18: db.session.add(usertable)\n19: db.session.commit()\n20: return make_response(\"회원가입 성공\", 200)\n\n\n\nPython 시큐어코딩 가이드\n⦁Django 프레임워크의 VALIDATORS 사용\nDjango에서는 미들웨어의 AUTH_PASSWORD_VALIDATORS 설정에서 패스워드에 대한 검증을 지원하며,\n기본적으로 아래와 같은 검증을 수행한다.\n⦁UserAttributeSimilarityValidator : 패스워드가 사용자의 다른 속성값(이름, 성, 이메일)등과의 유사도 확인\n⦁MinimumLengthValidator : 패스워드 길이의 최소값 확인(default 8)\n⦁CommonPasswordValidator : 사람들이 가장 많이 사용하는 패스워드 20,000개에 해당하는지 확인\n⦁NumericPasswordValidator : 패스워드가 숫자로만 구성되어있는지 확인\n기본 Validator 외에 필요한 추가 검증 기준이 있다면 사용자 정의 Validator를 생성한 후\nAUTH_PASSWORD_VALIDATORS에 등록해 적용 가능하다. 아래는 사용자 Validator 정의 예시를 보여\n준다(검증 통과 시 None 반환, 실패 시 ValidationError 발생하도록 구현 필요).",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: import re\n2: from django.core.exceptions import ValidationError\n3: from django.utils.translation import ugettext as _\n4:\n5: class CustomValidator(object):\n6: def validate(self, password, user=None):\n7: # 3종 이상 문자로 구성된 8자리 이상 패스워드 검사 정규식\n8: PT1 = re.compile('^(?=.*[A-Z])(?=.*[a-z])[A-Za-z\\d!@#$%^&*]{8,}$')\n9: PT2 = re.compile('^(?=.*[A-Z])(?=.*\\d)[A-Za-z\\d$@$!%*?&]{8,}$')\n10: PT3 = re.compile('^(?=.*[A-Z])(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$')\n11: PT4 = re.compile('^(?=.*[a-z])(?=.*\\d)[A-Za-z\\d!@#$%^&*]{8,}$')\n12: PT5 = re.compile('^(?=.*[a-z])(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$')\n13: PT6 = re.compile('^(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$')\n14:\n15: # 문자 구성 상관없이 10자리 이상 패스워드 검사 정규식\n16: PT7 = re.compile('^[A-Za-z\\d!@#$%^&*]{10,}$')\n17: for pattern in [PT1, PT2, PT3, PT4, PT5, PT6, PT7]:\n18: if pattern.match(password):\n19: return None\n20: raise ValidationError(\n21: _(\"패스워드 조합규칙에 적합하지 않습니다..\"),\n22: code='improper_password',\n23: )\n24:\n25: def get_help_text(self):\n26: return _(\n27: \"패스워드는 영문 대문자, 소문자, 숫자, 특수문자 조합 중 2가지 이상 8자리이거나 문자 구성\n28: 상관없이 10자리 이상이어야 합니다.\"\n29: )",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": [
        "패스워드 생성 시 강한 조건 검증을 수행한다. 패스워드(패스워드)는 숫자와 영문자, 특수문자 등을 혼합하여",
        "사용하고 주기적으로 변경하여 사용하도록 해야 한다."
      ]
    },
    {
      "section": "제2절 보안기능",
      "number": 10,
      "korean_name": "부적절한 전자서명 확인",
      "english_type": "Improper_Signature_Verification",
      "start_page": 98,
      "end_page": 101,
      "description": "프로그램, 라이브러리, 코드의 전자서명에 대한 유효성 검증이 적절하지 않아 공격자의 악의적인 코드가 실행\n가능한 보안약점으로, 클라이언트와 서버 사이의 주요 데이터 전송, 파일 다운로드 시 발생할 수 있다. 데이터\n전송 또는 다운로드 시 함께 전달되는 전자서명은 원문 데이터의 암호화된 해시 값으로, 수신측에서 이 서명을\n검증해 데이터 변조 여부를 확인할 수 있다. 단순히 해시 기반 검증만 사용할 경우 해시 자체를 변조해 악성코드를\n전달할 수 있지만 전자서명을 사용하게 되면 원문 데이터에 대한 해시 자체도 안전하게 보호할 수 있다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "주요 데이터 전송 또는 다운로드 시 데이터에 대한 전자서명을 함께 전송하고 수신측에서는 전달 받은 전자",
        "서명을 검증해 파일의 변조 여부를 확인해야 한다.",
        "Python 시큐어코딩 가이드",
        "안전한 코드 예시",
        "1: # 전자서명 검증에 사용한 코드는 의존한 파이썬 패키지 및 송신측 언어에 따라",
        "2: # 달라질 수 있으며, 사전에 공유한 공개키로 복호화한 전자서명과 원본 데이터 해시값의",
        "3: # 일치 여부를 검사하는 코드를 포함",
        "4: def verify_digit_signature (",
        "5: origin_data: bytes, origin_signature: bytes, client_pub_key: str ) -> bool:",
        "6: hashed_data = SHA256.new(origin_data)",
        "7: signer = SIGNATURE_PKCS1_v1_5.new(RSA.importKey(client_pub_key))",
        "8:",
        "9: return signer.verify(hashed_data, base64.b64decode(origin_signature))",
        "10:",
        "11: def verify_data(request):",
        "12: # 클라이언트로부터 전달받은 데이터",
        "13: encrypted_code = request.POST.get(\"encrypted_msg\", \"\") # 암호화된 파이썬 코드",
        "14: encrypted_sig = request.POST.get(\"encrypted_sig\", \"\") # 암호화된 전자서명",
        "15:",
        "16: # 서버의 대칭(비밀)키 및 공개키 로드",
        "17: with open(f\"/keys/secret_key.out\", \"rb\") as f:",
        "18: secret_key = f.read()",
        "19:",
        "20: with open(f\"/keys/public_key.out\", \"rb\") as f:",
        "21: public_key = f.read()",
        "22:",
        "23: # 대칭키로 파이썬 코드 및 전자서명 복호화",
        "24: origin_python_code = decrypt_with_symmetric_key(symmetric_key, encrypted_code)",
        "25: origin_signature = decrypt_with_symmetric_key(symmetric_key, encrypted_sig)",
        "26:",
        "27: # 클라이언트의 공개키를 통해 파이썬 코드(원문)와 전자서명을 검증",
        "28: verify_result = verify_digit_signature(origin_python_code, origin_signature, client_pub_key)",
        "29:",
        "30: # 전자서명 검증을 통과했다면 파이썬 코드 실행",
        "31: if verify_result:",
        "32: eval(origin_python_code)",
        "33: return render(request, \"/verify_success.html\",",
        "34: {\"result\": \"전자서명 검증 통과 및 파이썬 코드를 실행했습니다.\"},",
        "35: )",
        "36: else:",
        "37: return render(request, \"/verify_failed.html\",",
        "38: {\"result\": \"전자서명 또는 파이썬 코드가 위/변조되었습니다.\"},",
        "39: )"
      ]
    },
    {
      "section": "제2절 보안기능",
      "number": 11,
      "korean_name": "부적절한 인증서 유효성 검증",
      "english_type": "Improper_Certificate_Validation",
      "start_page": 102,
      "end_page": 105,
      "description": "인증서가 유효하지 않거나 악성인 경우 공격자가 호스트와 클라이언트 사이의 통신 구간을 가로채 신뢰하는\n엔티티 인 것처럼 속일 수 있다. 이로 인해 대상 호스트가 신뢰 가능한 것으로 믿고 악성 호스트에 연결하거나\n신뢰된 호스트로부터 전달받은 것처럼 보이는 스푸핑 된(또는 변조된 데이터)를 아무런 의심 없이 수신하는\n상황이 발생할 수 있다.",
      "unsafe_codes": [
        {
          "code": "다음은 SSL 기반 소켓 연결 예시로, 클라이언트 측에서 통신 대상 서버를 인증하지 않고 접속하는 상황을\n보여 준다. 이 경우 서버를 신뢰할 수 없으며 클라이언트 시스템에 영향을 주는 악성 데이터를 수신할 수 있다.\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: import os\n2: import socket\n3: import ssl\n4:\n5: CURRENT_PATH = os.getcwd()\n6: HOST_NAME = \"test-server\"\n7: HOST, PORT = \"127.0.0.1\", 7917\n8: SERVER_CA_PEM = f\"{CURRENT_PATH}/rsa_server/CA.pem\" # 서버로부터 전달받은 CA 인증서\n9:\n10: def connect_with_server():\n11:\n12: with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n13: # PROTOCOL_TLS_CLIENT 프로토콜을 추가하여 인증서 유효성 검사와 호스트 이름 확인을 위한\n14: # context를 구성. verify_mode가 CERT_REQUIRED로 설정됨\n15: # check_hostname이 True로 설정됨\n16: context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n17:\n18: # 서버로부터 전달받은 CA 인증서를 context에 로드\n19: # CERT_REQUIRED로 인해 필수\n20: context.load_verify_locations(SERVER_CA_PEM)\n21:\n22: # 호스트 이름(HOST_NAME)이 일치하지 않으면 통신 불가\n23: # 생성된 소켓과 context wrapping 시 server_hostname이 실제 서버에서\n24: # 등록(server.csr)한 호스트 명과 일치해야 함\n25: with context.wrap_socket(sock, server_hostname=HOST_NAME) as ssock:\n26: try:\n27: ssock.connect((HOST, PORT))\n28:\n29: ssock.send(\"Hello I'm a patched client :)\".encode(\"utf-8\"))\n30:\n31: data = ssock.recv(1024).decode(\"utf-8\")\n32:\n33: print(f\">> server from ({HOST}, {PORT}): {data}\\n\")\n34: finally:\n35: ssock.close()",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": [
        "데이터 통신에 인증서를 사용하는 경우 송신측에서 전달한 인증서가 유효한지 검증한 후 데이터를 송수신해야",
        "한다. 언어에서 기본으로 제공되는 검증 함수가 존재하지 않거나 일반적이지 않은 방식으로 인증서를 생성한",
        "경우 암호화 패키지를 사용해 별도의 검증 코드를 작성해야 한다."
      ]
    },
    {
      "section": "제2절 보안기능",
      "number": 12,
      "korean_name": "사용자 하드디스크에 저장되는 쿠키를 통한 정보 노출",
      "english_type": "Cookie_Exposure",
      "start_page": 106,
      "end_page": 108,
      "description": "대부분의 웹 응용프로그램에서 쿠키는 메모리에 상주하며, 브라우저가 종료되면 사라진다. 개발자가 원하는\n경우, 브라우저 세션에 관계없이 지속적으로 쿠키 값을 저장하도록 설정할 수 있다. 이 경우 정보는 디스크에\n기록되고 다음 브라우저 세션 시작 시 메모리에 로드 된다. 개인정보, 인증 정보 등이 이와 같은 영속적인 쿠키\n(Persistent Cookie)에 저장된다면, 공격자는 쿠키에 접근할 수 있는 보다 많은 기회를 가지게 되며, 이는\n시스템을 취약하게 만든다.",
      "unsafe_codes": [
        {
          "code": "다음은 쿠키의 만료시간을 과도하게 길게 설정해 사용자 하드 디스크에 저장된 쿠키가 도용되는 상황을 보여 준다.\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: from django.http import HttpResponse\n2: from django.conf.global_settings import (\n3: SESSION_COOKIE_AGE,\n4: SESSION_COOKIE_HTTPONLY,\n5: SESSION_COOKIE_HTTPONLY,\n6: )\n7:\n8: \"\"\"\n9: # settings.py\n10: SESSION_COOKIE_AGE = 60 * 60 * 24 * 14\n11: SESSION_COOKIE_HTTPONLY = True\n12: SESSION_COOKIE_SECURE = True\n13: \"\"\"\n14:\n15: def remind_user_state(request):\n16: res = HttpResponse()\n17: # 서버 세팅(setting.py)에서 default로 쿠키 옵션을 설정한 상태\n18: res.set_cookie(\n19: \"rememerme\",\n20: 1,\n21: max_age=SESSION_COOKIE_AGE,\n22: secure=SESSION_COOKIE_HTTPONLY,\n23: httponly=SESSION_COOKIE_HTTPONLY,\n24: )\n25: return res",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": [
        "쿠키의 만료시간은 세션 지속 시간을 고려하여 최소한으로 설정하고 영속적인 쿠키에는 사용자 권한 등급,",
        "세션 ID 등 중요 정보가 포함되지 않도록 한다."
      ]
    },
    {
      "section": "제2절 보안기능",
      "number": 13,
      "korean_name": "주석문 안에 포함된 시스템 주요정보",
      "english_type": "Information_in_Comments",
      "start_page": 109,
      "end_page": 110,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 14,
      "korean_name": "솔트 없이 일방향 해시 함수 사용",
      "english_type": "Missing_Salt",
      "start_page": 111,
      "end_page": 112,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 15,
      "korean_name": "무결성 검사없는 코드 다운로드",
      "english_type": "Unverified_Download",
      "start_page": 113,
      "end_page": 115,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제2절 보안기능",
      "number": 16,
      "korean_name": "반복된 인증시도 제한 기능 부재",
      "english_type": "Missing_Brute_Force_Protection",
      "start_page": 116,
      "end_page": 118,
      "description": "일정 시간 내에 여러 번의 인증 시도 시 계정 잠금 또는 추가 인증 방법 등의 충분한 조치가 수행되지 않는\n경우 공격자는 성공할 법한 계정과 패스워드들을 사전(Dictionary)으로 만들고 무차별 대입(brute-force)하여\n로그인 성공 및 권한 획득이 가능하다.\nDjango는 사용자 인증 요청 횟수를 제어하지 않는다. 인증 시스템에 대한 무차별 대입 공격으로부터 보호하기\n위해 Django 플러그인(django-defender) 또는 웹 서버 모듈을 사용하여 요청을 제한할 수도 있다.",
      "unsafe_codes": [
        {
          "code": "다음 예제는 사용자 로그인 시도에 대한 횟수를 제한하지 않는 코드를 보여 준다.\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "18: # 로그인 실패 기록 가져오기\n19: if LoginFail.objects.filter(user_id=user_id).exists():\n20: login_fail = LoginFail.objects.get(user_id=user_id)\n21: COUNT = login_fail.count\n22: else:\n23: COUNT = 0\n24:\n25: if COUNT >= LOGIN_TRY_LIMIT:\n26: # 로그인 실패횟수 초과로 인해 잠금된 계정에 대한 인증 시도 제한\n27: return render(request, \"/account_lock.html\", {\"state\": \"account_lock\"})\n28: else:\n29: # 로그인 실패 횟수 DB 기록\n30: # 첫 시도라면 DB에 insert,\n31: # 실패 기록이 존재한다면 update\n32: LoginFail.objects.update_or_create(\n33: user_id=user_id,\n34: defaults={\"count\": COUNT + 1},\n35: )\n36:\n37: return render(request, \"/login.html\", {\"state\": \"login_failed\"})",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": [
        "최대 인증시도 횟수를 적절한 횟수로 제한하고 설정된 인증 실패 횟수를 초과할 경우 계정을 잠금 하거나",
        "추가적인 인증 과정을 거쳐서 시스템에 접근이 가능하도록 한다. 코드 상에서 인증시도 횟수를 제한하는 방법",
        "외에 CAPTCHA나 Two-Factor 인증 방법도 설계 시부터 고려해야 한다."
      ]
    },
    {
      "section": "제3절 시간 및 상태",
      "number": 1,
      "korean_name": "경쟁조건: 검사시점과 사용시점(TOCTOU)",
      "english_type": "TOCTOU",
      "start_page": 119,
      "end_page": 121,
      "description": "",
      "unsafe_codes": [
        {
          "code": "다음 예제는 공유된 파일을 사용할 때 파일을 불러온 후 실제로 파일을 사용하는 부분이 실행되기 전 짧은\n시간에도 다른 사용자 또는 프로그램에 의해 파일이 사라져 원하는 기능을 실행할 수 없는 경우를 보여 준다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: import os\n2: import io\n3: import datetime\n4: import threading\n5:\n6: def write_shared_file(filename, content):\n7: # 멀티스레드 환경에서는 다른 사용자들의 작업에 따라 파일이 사라질 수\n8: # 있기 때문에 공유 자원에 대해서는 검사와 사용을 동시에 해야 한다.\n9: if os.path.isfile(filename) is True:\n10: f = open(filename, 'w')\n11: f.seek(0, io.SEEK_END)\n12: f.write(content)\n13: f.close()\n14:\n15: def start():\n16: filename = ‘./temp.txt’\n17: content = f“start time is {datetime.datetime.now()}”\n18: my_thread = threading.Thread(target=write_shared_file, args=(filename, content))\n19: my_thread.start()",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "변수, 파일과 같은 공유자원을 여러 프로세스가 접근하여 사용할 경우 동기화 구문을 사용하여 한 번에 하나의",
        "프로세스만 접근 가능하도록 해야 하며 성능에 미치는 영향을 최소화하기 위해 임계영역(critical section) 주변만",
        "동기화 구문을 사용한다.",
        "파이썬의 Lock 객체 사용 시 lock.acquire()로 자원을 잠그고 lock.release()로 자원을 해제해야 하며 이",
        "부분을 with 문을 사용해 간단하게 표현할 수 있다."
      ]
    },
    {
      "section": "제3절 시간 및 상태",
      "number": 2,
      "korean_name": "종료되지 않는 반복문 또는 재귀 함수",
      "english_type": "Infinite_Loop",
      "start_page": 122,
      "end_page": 124,
      "description": "재귀 함수의 순환 횟수를 제어하지 못해 할당된 메모리나 프로그램 스택 등의 자원을 개발자가 의도한 범위를\n과도하게 초과해 사용하면 위험하다. 대부분의 경우 기본 케이스(Base Case4))가 정의되어 있지 않은 재귀\n함수는 무한 루프에 빠져들게 되고 자원고갈을 유발함으로써 시스템의 정상적인 서비스를 제공할 수 없게 한다.\n파이썬에서는 재귀 함수의 재귀 반복 제한(Recursion Depth Limit)이 적용되어 있어 무한루프가 발생하지\n않으나, setrecursionlimit() 함수를 사용해 임의로 최대 깊이를 변경해 사용하는 경우 재귀 함수 호출 횟수가\n과도하게 많아지지 않도록 주의해야 한다.",
      "unsafe_codes": [
        {
          "code": "다음 코드 예시의 factorial 함수는 함수 내부에서 자신을 호출하는 함수로 재귀문을 빠져 나오는 조건을\n정의하고 있지 않아 시스템 장애를 유발할 수 있다.\n4)\u0000기본\u0000 케이스(Base\u0000Case)는\u0000 재귀\u0000호출을\u0000 하지\u0000않고\u0000반환하는\u0000방법을\u0000의미한다.\n\n\n\nPython 시큐어코딩 가이드",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "모든 재귀 호출 시 호출 횟수를 제한하거나 재귀 함수 종료 조건을 명확히 정의해 호출을 제어해야 한다.",
        "파이썬의 recursionlimit 제한은 스택 오버플로우 발생을 막기 위한 방법으로, recursionlimit 값을 과도하게",
        "큰 값으로 설정하지 않아야 한다."
      ]
    },
    {
      "section": "제4절 에러처리",
      "number": 1,
      "korean_name": "오류 메시지 정보노출",
      "english_type": "Error_Message_Exposure",
      "start_page": 125,
      "end_page": 128,
      "description": "",
      "unsafe_codes": [
        {
          "code": "사용자 요청을 정상적으로 처리할 수 없는 경우 에러 페이지에 디버그 정보 또는 서버의 정보가 노출될 수\n있다. 어플리케이션 배포 시 DEBUG 모드를 True로 설정하고 배포할 경우에 아래와 같이 시스템의 주요 정보가\n노출될 수도 있다. Django는 DEBUG 모드를 False로 배포했을 경우 아래와 같이 사용자 에러 페이지를 설정\n하지 않으면 Django 기본 에러 페이지가 출력된다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: # config/urls.py\n2: # 별도의 에러 페이지를 선언하지 않아 django의 기본 에러 페이지를 출력한다\n제공되는 에러 페이지 핸들러를 이용해 별도의 에러 페이지를 생성하여 사용자에게 표현하고 서버의 정보노출을\n최소화해야 한다.\n\n\n\nPython 시큐어코딩 가이드\n오류 처리 시 아래와 같이 에러 이름이나 에러 추적 정보가 노출되지 않도록 한다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [
        {
          "code": "1: import logging\n2:\n3: def fetch_url(url, useragent, referer=None, retries=1, dimension=False):\n4: ......\n5: try:\n6: response = requests.get(url, stream=True, timeout=5, headers={\n7: 'User-Agent': useragent,\n8: 'Referer': referer,\n9: })\n10: \u0000 \u0000 ......\n11: except IOError:\n12: # 에러 코드와 정보를 별도로 정의하고 최소 정보만 로깅\n13: logger.error('ERROR-01:통신에러')",
          "page": 0,
          "label": "안전한 코드 예시"
        }
      ],
      "recommendations": []
    },
    {
      "section": "제4절 에러처리",
      "number": 2,
      "korean_name": "오류상황 대응 부재",
      "english_type": "Missing_Error_Handling",
      "start_page": 129,
      "end_page": 131,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제4절 에러처리",
      "number": 3,
      "korean_name": "부적절한 예외 처리",
      "english_type": "Improper_Exception_Handling",
      "start_page": 132,
      "end_page": 133,
      "description": "프로그램 수행 중에 함수의 결과 값에 대한 적절한 처리 또는 예외 상황에 대한 조건을 적절하게 검사 하지\n않을 경우 예기치 않은 문제를 야기할 수 있다.",
      "unsafe_codes": [
        {
          "code": "다음 예제는 다양한 예외가 발생할 수 있음에도 불구하고 광범위한 예외 처리로 예외상황에 따른 적절한\n조치가 부적절한 사례를 보여 준다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: import sys\n2:\n3: def get_content():\n4: try:\n5: f = open('myfile.txt')\n6: s = f.readline()\n7: i = int(s.strip())\n8: # 예외처리를 세분화 할 수 있음에도 광범위하게 사용하여 예기치 않은\n9: # 문제가 발생할 수 있다\n10: except:\n11: print(\"Unexpected error \")\n다음은 발생 가능한 예외를 세분화한 후 예외상황에 따라 적합한 처리한 예시를 보여 준다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "값을 반환하는 모든 함수의 결과값을 검사해야 한다. 결과값이 개발자가 의도했던 값인지 검사하고 예외 처리를",
        "사용하는 경우에 광범위한 예외 처리 대신 구체적인 예외 처리를 수행한다."
      ]
    },
    {
      "section": "제5절 코드오류",
      "number": 1,
      "korean_name": "Null Pointer 역참조",
      "english_type": "Null_Pointer_Dereference",
      "start_page": 134,
      "end_page": 136,
      "description": "널 포인터(Null Pointer) 역참조는 '일반적으로 그 객체가 널(Null)이 될 수 없다'라고 하는 가정을 위반했을\n때 발생한다. 공격자가 의도적으로 널 포인터 역참조를 발생시키는 경우 공격자는 그 결과로 발생하는 예외\n상황을 이용해 추후 공격 계획에 활용할 수 있다.\n파이썬에서는 Null pointer dereference가 발생하지 않는다. 파이썬에서는 Null 객체가 사용되지 않으며\n대신 None 키워드를 사용해 null 개체와 변수를 정의 한다. None은 다른 언어의 null과 동일한 기능을 수행\n하지 않으며 None이 0 또는 다른 값을 정의 하진 않는다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "None을 반환하는 함수를 사용하면 None과 다른 값(예: 0이나 빈 문자열)이 조건문에서 False로 평가될",
        "수 있기 때문에 실수하기 쉽다. None이 될 수 있는 데이터를 참조하기 전에 해당 데이터의 값이 None 인지",
        "검사하여 시스템 오류를 줄일 수 있다.",
        "Python 시큐어코딩 가이드",
        "안전한 코드 예시",
        "1: import os",
        "2: from django.shortcuts import render",
        "3: from xml.sax import make_parser",
        "4: from xml.sax.handler import feature_namespaces",
        "5:",
        "6: def parse_xml(request):",
        "7: filename = request.POST.get('filename')",
        "8: # filename이 None 인지 체크",
        "9: if filename is None or filename.strip() == \"\":",
        "10: return render(request, \"/error.html\", {\"error\": \"파일 이름이 없습니다.\"})",
        "11:",
        "12: if (filename.count('.') > 0):",
        "13: name, ext = os.path.splitext(filename)",
        "14: else:",
        "15: ext = ''",
        "16:",
        "17: if ext == \".xml\":",
        "18: parser = make_parser()",
        "19: parser.setFeature(feature_namespaces, True)",
        "20: handler = Handler()",
        "21: parser.setContentHandler(handler)",
        "22: parser.parse(filename)",
        "23: result = handler.root",
        "24:",
        "25: return render(request, \"/success.html\", {\"result\": result})",
        "라. 참고자료",
        "① CWE-476: NULL Pointer Dereference, MITRE,",
        "https://cwe.mitre.org/data/definitions/476.html",
        "② Null Dereference, OWASP,",
        "https://owasp.org/www-community/vulnerabilities/Null_Dereference",
        "➂ Built-in Constants, Python Software Foundation,",
        "https://docs.python.org/3/library/constants.html?#None"
      ]
    },
    {
      "section": "제5절 코드오류",
      "number": 2,
      "korean_name": "부적절한 자원 해제",
      "english_type": "Improper_Resource_Release",
      "start_page": 137,
      "end_page": 139,
      "description": "",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제5절 코드오류",
      "number": 3,
      "korean_name": "신뢰할 수 없는 데이터의 역직렬화",
      "english_type": "Unsafe_Deserialization",
      "start_page": 140,
      "end_page": 142,
      "description": "직렬화(Serialization)는 프로그램에서 특정 클래스의 현재 인스턴스 상태를 다른 서버로 전달하기 위해 클래스의\n인스턴스 정보를 바이트 스트림으로 복사하는 작업으로, 메모리상에서 실행되고 있는 객체의 상태를 그대로\n복제해 파일로 저장하거나 수신 측에 전달하게 된다.\n역직렬화(Deserialization)는 반대 연산으로 바이너리 파일(Binary File) 이나 바이트 스트림(Byte Stream)\n으로부터 객체 구조로 복원하는 과정이다. 이 때 송신자가 네트워크를 이용해 직렬화된 정보를 수신자에게 전달\n하는 과정에서 공격자가 전송한 데이터 또는 저장된 스트림을 조작할 수 있는 경우 신뢰할 수 없는 역직렬화로\n인한 무결성 침해, 원격 코드 실행, 서비스 거부 공격 등이 발생 할 수 있는 보안약점이다.\n파이썬에서는 pickle 모듈을 통해 직렬화(pickle) 및 역직렬화(unpickle)를 수행할 수 있다. pickle 모듈은\n데이터 변조에 대한 검증 과정이 없기 때문에 임의의 코드를 실행하는 악의적인 pickle 데이터를 구성할 수 있어\npickle을 사용해 역직렬화 하는 경우 hmac으로 데이터에 서명하거나 json 모듈을 사용하는 것을 고려해야 한다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "초기화되지 않은 스택 메모리 영역의 변수는 임의값이라고 생각해서 대수롭지 않게 생각할 수 있으나 사실은",
        "이전 함수에서 사용되었던 내용을 포함하고 있다. 공격자는 이러한 약점을 사용하여 메모리에 저장되어 있는",
        "값을 읽거나 특정 코드를 실행할 수 있다. 모든 변수를 사용 전에 반드시 올바른 초기 값을 할당함으로서 이러한",
        "문제를 예방할 수 있다.",
        "Python 시큐어코딩 가이드",
        "안전한 코드 예시",
        "1: import hmac",
        "2: import hashlib",
        "3: import pickle",
        "4: from django.shortcuts import render",
        "5:",
        "6: def load_user_object(request):",
        "7: # 데이터 변조를 확인하기 위한 해시값",
        "8: hashed_pickle = request.POST.get(\"hashed_pickle\", \"\")",
        "9:",
        "10: # 사용자로부터 입력받은 데이터를 직렬화(pickle)",
        "11: pickled_userinfo = pickle.dumps(request.POST.get(\"userinfo\", \"\"))",
        "12:",
        "13: # HMAC 검증을 위한 비밀키는 생성",
        "14: m = hmac.new(key=\"secret_key\".encode(\"utf-8\"), digestmod=hashlib.sha512)",
        "15:",
        "16: # 직렬화된 사용자 입력값을 해싱",
        "17: m.update(pickled_userinfo)",
        "18:",
        "19: # 전달받은 해시값(hashed_pickle)과 직렬화 데이터(userinfo)의 해시값을 비교하여 검증",
        "20: if hmac.compare_digest(str(m.digest()), hashed_pickle):",
        "21: user_obj = pickle.loads(pickled_userinfo)",
        "22: return render(request, \"/load_user_obj.html\", {\"obj\": user_obj})",
        "23: else:",
        "24: return render(request, \"/error.html\", {\"error\": \"신뢰할 수 없는 데이터입니다.\"}",
        "라. 참고자료",
        "① CWE-502: Deserialization of Untrusted Data, MITRE,",
        "https://cwe.mitre.org/data/definitions/502.html",
        "② Deserialization Cheat Sheet, OWASP,",
        "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html",
        "③ Python object serialization, Python Software Foundation,",
        "https://docs.python.org/3/library/pickle.html"
      ]
    },
    {
      "section": "제6절 캡슐화",
      "number": 1,
      "korean_name": "잘못된 세션에 의한 데이터 정보 노출",
      "english_type": "Session_Data_Exposure",
      "start_page": 143,
      "end_page": 145,
      "description": "",
      "unsafe_codes": [
        {
          "code": "다중 스레드 환경에서 파이썬의 클래스 변수는 스레드 간 서로 공유하게 된다. 클래스 변수에 값을 할당할\n경우 서로 다른 세션 간에 데이터가 공유되어 의도하지 않은 데이터가 전달될 수 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: from django.shortcuts import render\n2:\n3: class UserDescription:\n4: user_name = ''\n5:\n6: def get_user_profile(self):\n7: result = self.get_user_discription(UserDescription.user_name)\n8: ......\n9: return result\n10:\n11: def show_user_profile(self, request):\n12: # 클래스변수는 다른 세션과 공유되는 값이기 때문에 멀티스레드\n13: # 환경에서 공유되지 않아야 할 자원을 사용하는 경우\n14: # 다른 스레드 세션에 의해 데이터가 노출될 수 있다\n15: UserDescription.user_name = request.POST.get(‘name’, ‘’)\n16: self.user_profile = self.get_user_profile()\n17:\n18: return render(request, 'profile.html', {'profile':self.user_profile})\n공유가 금지된 변수는 인스턴스 변수로 선언하여 세션 간에 공유되지 않도록 한다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": []
    },
    {
      "section": "제6절 캡슐화",
      "number": 2,
      "korean_name": "제거되지 않고 남은 디버그 코드",
      "english_type": "Debug_Code",
      "start_page": 146,
      "end_page": 149,
      "description": "디버깅 목적으로 삽입된 코드는 개발이 완료되면 제거해야 한다. 디버그 코드는 설정 등의 민감한 정보 또는\n의도하지 않은 시스템 제어로 이어질 수 있는 정보를 담고 있을 수 있다. 만일 디버그 코드가 남겨진 채로\n배포될 경우 공격자가 식별 과정을 우회하거나 의도하지 않은 정보 노출로 이어질 수 있다.\nDjango 프레임워크, Flask 프레임워크는 전역 수준에서 DEBUG 모드를 설정할 수 있다. DEBUG 모드를\n사용하면 브라우저에서 임의의 파이썬 코드를 실행할 수도 있고 파이썬에서 발생한 모든 오류가 출력되어 정보\n노출의 위험이 있다. 어플리케이션을 배포 전에 반드시 DEBUG 모드를 비활성화 해야 한다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "소프트웨어 배포 전 반드시 디버그 코드를 확인 및 삭제한다. Django 프레임워크의 경우 전역 수준에서",
        "DEBUG 모드를 비활성화 하려면 settings.py 파일에 설정을 하고 Flask 프레임워크는 app_run() 전에",
        "debug = False로 설정하면 된다.",
        "Python 시큐어코딩 가이드",
        "나) Flask 예제",
        "다음은 Flask의 예제로, debug 모드가 True로 설정되어 정보 노출의 위험이 있다.",
        "안전하지 않은 코드 예시",
        "1: from flask import Flask",
        "2:",
        "3: app = Flask(__name__)",
        "4: # 디버그 모드 설정 방법1",
        "5: app.debug = True",
        "6:",
        "7: @app.route('/')",
        "8: def hello_world():",
        "9: return 'Hello World!'",
        "10:",
        "11: if __name__ == '__main__':",
        "12: app.run()",
        "13: # 디버그 모드 설정 방법2",
        "14: app.run(debug=True)",
        "마찬가지로 개발이 끝난 소스코드를 배포 및 운영 시 반드시 debug 옵션을 False로 변경해야 한다.",
        "안전한 코드 예시",
        "1: from flask import Flask",
        "2:",
        "3: app = Flask(__name__)",
        "4: app.debug = False",
        "5:",
        "6: @app.route('/')",
        "7: def hello_world():",
        "8: return 'Hello World!'",
        "9:",
        "10: if __name__ == '__main__':",
        "11: app.run()",
        "12:",
        "13: app.run(debug=False)"
      ]
    },
    {
      "section": "제6절 캡슐화",
      "number": 3,
      "korean_name": "Public 메소드로부터 반환된 Private 배열",
      "english_type": "Private_Array_Return",
      "start_page": 150,
      "end_page": 151,
      "description": "파이썬은 명시적인 private 선언이 없다. 하지만 대부분의 파이썬 코드가 따르는 규칙으로 이름 앞에 밑줄\n(예:__spam)로 시작하면 private 로 처리된다. public으로 선언된 메소드에서 배열을 반환하면 해당 배열의\n참조 객체가 외부에 공개되어 외부에서 배열 수정과 객체 속성 변경이 가능해진다. 이러한 속성은 배열 뿐만\n아니라 변경 가능한(mutable) 모든 객체에 해당된다.\n구분 표시 방법\npublic attribute, method는 기본적으로 public\nattribute, method 앞에 _(single underscore)를 붙여서 표시 함.\nprotect\n실제 제약 보다는 관례적임.\nattribute, method 앞에 __(double underscore)를 붙여서 표시 함.\nprivate 파이썬은 네임 맹글링(name mangling)으로 private 멤버에 _class__member로 접근은 가능하지만\n바람직하지 않음.",
      "unsafe_codes": [
        {
          "code": "다음 예제는 private 변수를 생성하고 이를 반환하는 public 메소드를 사용하는 예시를 보여 준다. 이 경우\n외부에서 클래스 내에 숨겨져 있는 private 배열 값에 접근할 수 있는 문제점이 발생한다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "private로 선언된 배열을 public으로 선언된 메소드로 반환하지 않도록 한다. private 배열에 대한 복사본을",
        "반환하도록 하고 배열의 원소에 대해서는 clone() 메소드를 통해 복사된 원소를 저장하도록 해서 private 선언된",
        "배열과 객체 속성에 대한 의도치 않은 수정을 방지한다. 만약 배열의 원소가 String 타입 등과 같이 변경이",
        "되지 않는 경우(immutable)에는 private 배열의 복사본을 만들고 이를 반환하도록 작성한다."
      ]
    },
    {
      "section": "제6절 캡슐화",
      "number": 4,
      "korean_name": "Private 배열에 Public 데이터 할당",
      "english_type": "Public_Data_Assignment",
      "start_page": 152,
      "end_page": 153,
      "description": "public으로 선언된 메소드의 인자가 private로 선언된 배열에 저장되면 private 배열을 외부에서 접근하여\n배열 수정과 객체 속성 변경이 가능해진다.",
      "unsafe_codes": [
        {
          "code": "다음 예제는 __를 이용해서 파이썬의 내부 배열을 생성하고 외부 값을 대입하는 public 메소드를 사용하는\n예시를 보여 준다. 이 경우 특정 배열 타입에 따라 외부에서 private 배열을 변조할 수 있는 문제를 내포하고 있다.",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        },
        {
          "code": "1: class UserObj:\n2: __private_variable = []\n3: def __init__(self):\n4: pass\n5:\n6: # private 배열에 외부 값을 바로 대입하는 public 메소드를 사용하는\n7: # 경우 취약하다\n8: def set_private_member(self, input_list):\n9: self.__private_variable = input_list",
          "page": 0,
          "label": "안전하지 않은 코드 예시"
        }
      ],
      "safe_codes": [],
      "recommendations": [
        "public으로 선언된 메소드의 인자를 private 로 선언된 배열에 저장하지 않도록 한다. 사용자가 전달한 값으로",
        "클래스 외부에서 private 값을 변경해서는 안 되며, 필요한 경우 별도의 인스턴스 변수로 정의하거나 의도한",
        "기능이라면 전달된 값의 정상 여부를 검증한 후 적용해야 한다."
      ]
    },
    {
      "section": "제7절 API 오용",
      "number": 1,
      "korean_name": "DNS lookup에 의존한 보안결정",
      "english_type": "DNS_Based_Security",
      "start_page": 154,
      "end_page": 155,
      "description": "공격자가 DNS 엔트리를 속일 수 있으므로 도메인명에 의존에서 보안결정(인증 및 접근 통제 등)을 하지\n않아야 한다. 만약 로컬 DNS 서버의 캐시가 공격자에 의해 오염된 상황이라면 사용자와 특정 서버 간의 네트워크\n트래픽이 공격자를 경유하도록 할 수도 있다. 또한 공격자가 마치 동일 도메인에 속한 서버인 것처럼 위장 할\n수도 있다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": [
        "보안결정에서 도메인명을 이용한 DNS lookup을 하지 않도록 한다."
      ]
    },
    {
      "section": "제7절 API 오용",
      "number": 2,
      "korean_name": "취약한 API 사용",
      "english_type": "Vulnerable_API",
      "start_page": 156,
      "end_page": 170,
      "description": "취약한 API는 보안상 금지된 함수이거나 부주의하게 사용될 가능성이 많은 API를 의미한다. 별도의 외부\n의존성 없이 언어 엔진에서 제공하는 기능만으로 큰 규모의 프로그램 제작이 용이한 C/C++과 같은 언어와\n달리, 파이썬은 외부 의존성을 기본으로 하는 생태계를 토대로 한다. 패키지(package)라고 부르는 모듈 집합을\n통해 서로 다른 제작자의 작업 결과물을 손쉽게 프로그램에 탑재하고 활용할 수 있다. 이러한 파이썬의 생태계는\n언어 활용성과 확장성 측면에서 굉장히 큰 이점을 가지고 있으며, 소프트웨어 개발의 접근성을 크게 높여주는데\n기여했다(파이썬 기본 설치 시 제공되는 엔진 코드도 패키지 형태로 코드에서 사용할 수 있다).\n하지만 이러한 파이썬 언어의 특성은 잠재적인 보안 위협을 내포하고 있으며 주의하지 않을 경우 소프트웨어에\n심각한 문제를 가져다 줄 수 있다. 파이썬 패키지는 기본적으로 다른 개발자가 작성한 코드로, 의도적인 악성코드를\n포함할 수 있을뿐만 아니라 의도하지 않은 오류 또는 약점으로 인해 또 다른 보안 문제를 야기할 수 있다.\n파이썬 패키지 설치에 사용되는 pip 도구는 파이썬 패키지 인덱스(PyPI)에 등록된 파이썬 패키지를 검색\n및 설치하는 도구로, 누구나 여기에 패키지를 등록해 배포할 수 있다. 물론 대부분의 경우 많은 오픈소스 개발자\n들의 피드백과 평점, 그리고 레퍼런스가 쌓인 패키지를 사용하겠지만, 이와는 별개로 그 누구도 패키지 내부에\n취약점이 없다는 보장을 할 수 없다. 안전하지 않은 것으로 알려진 패키지에 대해서는 PyPI에서 따로 그 목록을\n관리하지만, 잘 알려지지 않은 패키지로 인한 위험은 여전히 존재한다.\n프로그램 코드에서 외부 패키지 사용 시 보안 문제가 발생하게 되는 원인을 크게 두 가지로 분류할 수 있다.\n첫 번째, 사용자 배포 패키지 내의 결함으로 인한 취약점\n두 번째, 언어 엔진 자체의 결함으로 인한 취약점(기본 제공 패키지)\n\n사용자 배포 패키지 내의 결함은 말 그대로 패키지 코드 내에 보안 약점이 존재하는 경우를 의미한다. 많은\n경우 특정 함수의 데이터 처리 로직 문제로 의도된 조작값을 함수에 전달할 경우 보안취약점이 발생하는 방식\n으로 동작하며, 이는 개발자의 개발 방식에도 영향을 주게 된다. 완화 방안으로는 취약한 패키지를 사용하지\n않거나 취약한 버전을 사용하지 않거나, 함수 실행 전후 보호 루틴을 적용해 코드를 보호하는 방법이 있다.\n언어 엔진 내부에서도 보안 결함이 지속적으로 발견되고 있다. 엔진 내부 결함은 대부분 개발자의 개발 방식에\n영향을 주지 않으며 취약점과 관련된 로직이 포함된 경우에만 문제가 될 수 있다. 엔진 결함은 해당 취약점이\n개선된 버전으로 Node.js 버전을 업데이트 해서 완화할 수 있다.\n나. 안전한 API 선택\n근본적인 대응 방법은 취약한 API를 코드에 사용하지 않는 것이다. 하지만 이는 파이썬 생태계에서는 적용이\n어려운 방법이며, 설령 안전한 것으로 판단된 API라고 하더라도 취약점이 발견되지 않으리라는 보장도 없다.\n그렇다고 매번 새로운 패키지를 사용할 때마다 패키지 내에 보안 결함이 있는지 일일이 분석하는 것도 불가능한\n작업이다. 가장 현실적인 방법은 최초 패키지 사용 시 다음과 같은 내용을 검토해 패키지 사용 여부를 결정하는\n것이다.\n- 사용 통계 : 얼마나 많은 사람들이 해당 패키지를 다운로드 했고, 선호하고 있는지\n- 이슈 관리 : 지속적으로 발견되는 버그 또는 이슈를 어떻게 처리하고 있는지\n- 마지막 버전 : 코드 유지관리가 잘 되고 있는지\n- 발견된 취약점 : 특정 버전에서 취약점이 발견 되었는지, 그리고 결함이 제거된 버전이 공개되어 있는지\n(프로그램 개발 완료 시점에 한 번 더 체크해 주어야 함)\n많은 사람들이 사용하고 지속적인 이슈 관리 및 업데이트를 지원하는 패키지의 경우 상대적으로 보안 문제가\n발생할 확률이 낮으며, 설령 문제가 생겨도 빠르게 처리가 될 것이라고 생각할 수 있다. 이렇듯 가장 중요한\n부분은 패키지 관리 수준으로, 오픈소스의 특성 상 정식 벤더사들의 제품처럼 빠른 패치를 항상 기대할 수 없으며\n사용자 입장에서 이를 한 눈에 판단하기도 어려운 일이다. 참고를 위해 사용하고자 하는 패키지에 취약점이\n존재하는지 검색해 볼 수 있는 사이트를 몇 가지 제시해 본다.\n\n이름 주소 설명\nNIST(National Vulnerability 미국국립표준기술연구소에서 제공하는 취약점\nhttps://nvd.nist.gov/vuln/search\nDatabase) 검색 서비스\nCVE 정보 검색, 통계 확인 등을 제공하는 온라인\nCVEdetails https://www.cvedetails.com\n서비스\n예를 들어 urllib 패키지를 사용하고 싶을 때 우선 NIST 데이터베이스에 urllib를 검색해 본다. 해당 키워드가\n포함된 취약점 코드 및 설명이 화면에 출력되고 사용하고자 하는 패키지와 일치하는 버전을 찾으면 된다. 만약\n현재 사용 중이거나 사용 예정인 패키지 버전에 영향을 주는 취약점이 발견될 경우 취약점이 패치된 버전을\n프로그램에 적용해야 한다. 만약 아직 보안 패치가 적용된 버전이 공개되지 않은 경우라면 다음 섹션인 ‘사후\n관리’에서 제시하는 방법과 절차에 따라 취약점 악용을 예방해야 한다.\n앞서 제시한 방법을 통해 안전한 패키지를 선택할 수는 있지만, 이 과정이 취약점 발생 위협을 완전히 차단해\n주지는 못한다. 오픈소스 생태계는 지속적인 변화와 확장을 태생으로 하고 있으며 지속적인 관심과 체계적인\n관리를 통해 발생 가능한 취약점에 대비하고 대응해야 한다.\n\n다. 사후 관리\n모든 API는 보안 취약점에서 완전히 자유로울 수 없다. 안전한 API를 선택했더라도 지속적인 모니터링 및\n관리가 이루어지지 않으면 취약점 공격에 노출될 수 있다. 개발 제품에 오픈소스를 사용하는 경우 SBOM\n(Software Bill of Material)을 적용해야 한다. SBOM은 소프트웨어 자제 명세서, 즉 모든 소프트웨어 정보를\n담고 있는 명세서를 의미한다. 물리적인 실체가 있는 제조 상품과 달리, 소프트웨어 공급자가 소프트웨어 전체\n를 모두 직접 개발하지 않으므로 문제 발생 시 이를 신속하게 찾아 해결하는 것이 매우 어렵다. SBOM은 코드\n에 포함된 모든 오픈소스 및 써드 파티 컴포넌트 목록이자 각 항목의 라이선스, 버전, 패치 상태 등을 제공해\n빠른 보안 이슈 및 라이선스 위험에 대응할 수 있게 해 주는 중요한 도구다.\n미국 정부 주도 하에 진행된 연구를 토대로 NTIA(미국 전기통신 및 정보청)에서 SBOM 가이드 및 FAQ를\n공개했으며, 해당 가이드에서는 SBOM의 필수 구성요소로 다음과 같은 항목을 제시했다.\n- 공급자 이름, 컴포넌트 이름, 컴포넌트 버전, 컴포넌트 해시, 고유 특성자(UID), 의존 관계, 작성자\n쉽게 말해서, 파이썬으로 개발한 소프트웨어에서 의존하는 모든 패키지에 대해 상기 내용을 별도의 자료로\n작성해서 관리해야 한다는 의미와 같다. SBOM 목록 내의 의존 패키지들에 대한 최신 보안 이슈 및 업데이트\n정보를 제공하는 서비스를 이용하거나 주기적인 목록 최신화를 통해 관련 내용을 지속적으로 업데이트 하는\n방법이 있다. 다음은 SBOM이 적용된 취약점 대응 프로세스 예시를 보여 준다.\n1) 신규 취약점 발생 인지 : 신규 취약점 모니터링 과정에서 발견된 신규 취약점 위협 정보 입수\n2) SBOM 목록 탐색 : 조직에서 운용 중인 제품의 SBOM 목록에 신규 취약점 관련 컴포넌트가 있는지 탐색\n\n3) 취약점 발생 대응: SBOM 목록 내에 관련 컴포넌트가 존재하는 경우\n(1) 사내 정보 공유 : 취약점이 발생한 (또는 발생할 수 있는) 소프트웨어 관련 담당자에게 취약점 정보\n제공을 통해 상황을 인지시키고 발생 가능한 위험에 대비할 수 있도록 준비\n(2-1) 보안 솔루션 정책 반영 : (침입 탐지 제품을 이용 중인 경우) 제품단에서 취약점 악용 시도 및 공격을\n차단할 수 있도록 패턴 개발 및 반영\n(2-2) 소스코드 수정 / 예외처리 : 취약점이 존재하는 소프트웨어의 소스코드 관리 책임이 조직 내에 있는\n경우 해당 컴포넌트에서 취약점이 발생하지 않도록 또는 취약점 발생을 방지할 수 있는 임시 예외\n코드를 추가하고, 소스코드 관리 책임이 외부 업체 또는 기관에 있는 경우 상황 전파 및 대응 결과 회신\n(3) 패키지 업데이트 : 취약점이 존재하는 컴포넌트를 개발한 개발사 또는 조직에서 공개한 취약점 개선\n버전을 소프트웨어 패키지에 적용(업데이트)\n4) SBOM 목록 최신화 : 취약점 개선 버전이 반영된 패키지의 세부 정보를 SBOM 목록에 반영\n소프트웨어 취약점을 완벽히 차단하는 방법은 없다. 특히 오픈소스의 경우 소스코드 내부에 대한 검토가 현실\n적으로 거의 불가능하므로 오픈소스 내의 취약점으로 인한 보안 위협은 특히 추적 및 관리가 어렵다. 따라서\n지속적인 모니터링 및 관리를 통해 소프트웨어를 보호하고 개선해야 한다.\n라. 참고자료\n① NTIA - SBOM,\nhttps://www.ntia.gov/page/software-bill-materials\n② CISA - SBOM,\nhttps://www.cisa.gov/sbom\n\n\n\n\n부 록\n제1절 구현단계 보안약점 제거 기준\n1. 입력데이터 검증 및 표현\n번호 보안약점 설명\nSQL 질의문을 생성할 때 검증되지 않은 외부 입력값을 허용하여 악의적인 질의문이 실행가능한\n1 SQL 삽입\n보안약점\n프로세스가 외부 입력값을 코드(명령어)로 해석·실행할 수 있고 프로세스에 검증되지 않은 외부\n2 코드 삽입\n입력값을 허용한 경우 악의적인 코드가 실행 가능한 보안약점\n시스템 자원 접근경로 또는 자원제어 명령어에 검증되지 않은 외부 입력값을 허용하여 시스템\n3 경로 조작 및 자원 삽입\n자원에 무단 접근 및 악의적인 행위가 가능한 보안약점\n사용자 브라우저에 검증되지 않은 외부 입력값을 허용하여 악의적인 스크립트가 실행 가능한\n4 크로스사이트 스크립트\n보안약점\n운영체제 명령어를 생성할 때 검증되지 않은 외부 입력값을 허용하여 악의적인 명령어가 실행\n5 운영체제 명령어 삽입\n가능한 보안약점\n6 위험한 형식 파일 업로드 파일의 확장자 등 파일형식에 대한 검증없이 파일 업로드를 허용하여 공격이 가능한 보안약점\n신뢰되지 않는 URL URL 링크 생성에 검증되지 않은 외부 입력값을 허용하여 악의적인 사이트로 자동 접속 가능한\n\n주소로 자동접속 연결 보안약점\n부적절한 XML\n8 임의로 조작된 XML 외부개체에 대한 적절한 검증 없이 참조를 허용하여 공격이 가능한 보안약점\n외부 개체 참조\nXQuery, XPath 질의문을 생성할 때 검증되지 않은 외부 입력값을 허용하여 악의적인 질의문이\n9 XML 삽입\n실행 가능한 보안약점\nLDAP 명령문을 생성할 때 검증되지 않은 외부 입력값을 허용하여 악의적인 명령어가 실행\n10 LDAP 삽입\n가능한 보안약점\n사용자 브라우저에 검증되지 않은 외부 입력값을 허용하여 사용자 본인의 의지와는 무관하게\n11 크로스사이트 요청 위조\n공격자가 의도한 행위가 실행 가능한 보안약점\n서버 간 처리되는 요청에 검증되지 않은 외부 입력값을 허용하여 공격자가 의도한 서버로 전송\n12 서버사이드 요청 위조\n하거나 변조하는 보안약점\nHTTP 응답헤더에 개행문자(CR이나 LF)가 포함된 검증되지 않은 외부 입력값을 허용하여 악의\n13 HTTP 응답분할\n적인 코드가 실행 가능한 보안약점\n정수형 변수에 저장된 값이 허용된 정수 값 범위를 벗어나 프로그램이 예기치 않게 동작 가능한\n14 정수형 오버플로우\n보안약점\n\nPython 시큐어코딩 가이드\n번호 보안약점 설명\n보안기능 결정에 사용 보안기능(인증, 권한부여 등) 결정에 검증되지 않은 외부 입력값을 허용하여 보안기능을 우회하는\n\n되는 부적절한 입력값 보안약점\n16 메모리 버퍼 오버플로우 메모리 버퍼의 경계값을 넘어서 메모리값을 읽거나 저장하여 예기치 않은 결과가 발생하는 보안약점\nstr.format등 포맷 스트링 제어함수에 검증되지 않은 외부 입력값을 허용하여 발생하는 보안약점\n17 포맷 스트링 삽입\n* 포맷 스트링: 입·출력에서 형식이나 형태를 지정해주는 문자열\n2. 보안기능\n번호 보안약점 설명\n적절한 인증 없는 중요정보(금융정보, 개인정보, 인증정보 등)를 적절한 인증없이 열람(또는 변경) 가능한\n\n중요 기능 허용 보안약점\n2 부적절한 인가 중요자원에 접근할 때 적절한 제어가 없어 비인가자의 접근이 가능한 보안약점\n중요한 자원에 대한\n3 중요자원에 적절한 접근 권한을 부여하지 않아 중요정보가 노출·수정 가능한 보안약점\n잘못된 권한 설정\n취약한 암호화 중요정보 (금융정보, 개인정보, 인증정보 등)의 기밀성을 보장할 수 없는 취약한 암호화 알\n\n알고리즘 사용 고리즘을 사용하여 정보가 노출 가능한 보안약점\n중요정보(패스워드, 개인정보 등) 전송 시 암호화 또는 안전한 통신채널을 이용하지 않거나,\n5 암호화되지 않은 중요정보\n저장 시 암호화 하지 않아 정보가 노출 가능한 보안약점\n소스코드에 중요정보(패스워드, 암호화키 등)를 직접 코딩하여 소스코드 유출 시 중요정보가\n6 하드코드된 중요정보\n노출되고 주기적 변경이 어려운 보안약점\n충분하지 않은 키 암호화 등에 사용되는 키의 길이가 충분하지 않아 데이터의 기밀성·무결성을 보장할 수 없는\n\n길이 사용 보안약점\n적절하지 않은 사용한 난수가 예측 가능하여, 공격자가 다음 난수를 예상해서 시스템을 공격 가능한 보안\n\n난수 값 사용 약점\n패스워드 조합규칙(영문, 숫자, 특수문자 등) 미흡 및 길이가 충분하지 않아 패스워드가\n9 취약한 패스워드 허용\n노출 가능한 보안약점\n프로그램, 라이브러리, 코드의 전자서명에 대한 유효성 검증이 적절하지 않아 공격자의\n10 부적절한 전자서명 확인\n악의적인 코드가 실행 가능한 보안약점\n부적절한 인증서\n11 인증서에 대한 유효성 검증이 적절하지 않아 발생하는 보안약점\n유효성 검증\n사용자 하드디스크에 저장되는 쿠키(세션 ID, 사용자 권한정보 등 중요정보)를 사용자 하드디스크에 저장하여 중요정보가\n\n쿠키를 통한 정보노출 노출 가능한 보안약점\n주석문 안에 포함된 소스코드 주석문에 인증정보 등 시스템 주요정보가 포함되어 소스코드 노출 시 주요정보도\n\n시스템 주요정보 노출 가능한 보안약점\n솔트를 사용하지 않고 생성된 해시 값으로부터 공격자가 미리 계산된 레인보우 테이블을\n솔트 없이 일방향\n14 이용하여 해시 적용 이전 원본 정보를 복원가능한 보안약점\n해시 함수 사용\n*솔트: 해시 적용하기 전 평문인 전송정보에 덧붙인 무의미한 데이터\n무결성 검사 없는 코드 소스코드 또는 실행파일을 무결성 검사 없이 다운로드 받아 실행하는 경우, 공격자의 악의\n\n다운로드 적인 코드가 실행 가능한 보안약점\n반복된 인증시도 인증 시도 수를 제한하지 않아 공격자가 반복적으로 임의 값을 입력하여 계정 권한을 획득\n\n제한 기능 부재 가능한 보안약점\n\n\n\nPython 시큐어코딩 가이드\n제2절 용어정리\n● Developer Economics State of the Developer Nation, 20th Edition\ndevelopernation.net에서 매년 165개국 30,000명 이상의 개발자들을 대상으로 설문조사를 하여 제공하고 있다. 웹, 모바일,\n데스크톱, 클라우드, 산업용 IoT, 소비자 전자 제품, 임베디드소프트웨어, AR 및 VR등 다양한 분야의 설문을 실시하고 있다.\n● AES(Advanced Encryption Standard)\n미국 정부 표준으로 지정된 블록 암호 형식으로 이전의 DES를 대체하며, 미국 표준 기술 연구소 (NIST)가 5년의 표준화\n과정을 거쳐 2001년 11월 26일에 연방 정보처리표준(FIPS 197)으로 발표하였다.\n● DES 알고리즘\nDES(Data Encryption Standard)암호는 암호화 키와 복호화키가 같은 대칭키 암호로 64비트의 암호화키를 사용한다.\n전수공격(Brute Force)공격에 취약하다.\n● HMAC(Hash-based Message Authentication Code)\n해시 기반 메시지 인증 코드, MD5, SHA-1 등 반복적인 암호화 해시 기능을 비밀 공용키와 함께 사용하며, 체크섬을\n변경하는 것이 불가능하도록 한 키 기반의 메시지 인증 알고리즘이다.\n● HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)\nWWW(월드 와이드 웹) 통신 프로토콜인 HTTP의 보안이 강화된 버전이다.\n● LDAP(Lightweight Directory Access Protocol)\nTCP/IP 위에서 디렉토리 서비스를 조회하고 수정하는 응용 프로토콜이다.\n● SHA(Secure Hash Algorithm)\n해시알고리즘의 일종으로 MD5의 취약성을 대신하여 사용한다. SHA, SHA‐1, SHA‐2(SHA‐224, SHA‐256, SHA‐384,\nSHA‐512) 등의 다양한 버전이 있으며, 암호 프로토콜인 TLS, SSL, PGP, SSH, IPSec 등에 사용된다.\n● umask\n파일 또는 디렉토리의 권한을 설정하기 위한 명령어이다.\n● 개인키(Private Key)\n공개키 기반구조에서 개인키란 암·복호화를 위해 비밀 메시지를 교환하는 당사자만이 알고 있는 키이다.\n● 공개키(Public Key)\n공개키는 지정된 인증기관에 의해 제공되는 키값으로서, 이 공개키로부터 생성된 개인키와 함께 결합되어, 메시지 및 전자\n서명의 암·복호화에 효과적으로 사용될 수 있다. 공개키를 사용하는 시스템을 공개키 기반구조(Public Key Infrastructure,\nPKI)라 한다.\n● 경로순회(directory traversal)\n상대경로 참조 방식(“./”,“../”등)을 이용해 다른 디렉토리의 중요파일에 접근하는 공격방법으로 경로 추적이라고도 한다.\n\n\n\nPython 시큐어코딩 가이드\n● 파싱(Parsing)\n일련의 문자열을 의미 있는 token(어휘 분석의 단위)으로 분해하고 그것들로 이루어진 Parse tree를 만드는 과정이다. 어떤\n문장을 분석하거나 문법적 관계를 해석하는 행위를 말한다.\n● 파서(Parser)\n컴파일러(compiler)의 일부로 컴파일러나 인터프리터(Interpreter)에서 원시 프로그램을 읽어 들여 그 문장의 구조를 알아\n내는 parsing(구문 분석)을 행하는 프로그램을 말한다.\n● XML(eXtensible Markup Language)\nW3C에서 개발되었으며, 다른 특수한 목적을 갖는 마크업 언어를 만드는데 사용된다. 인터넷에 연결된 시스템끼리 데이터를\n쉽게 주고받을 수 있어 HTML의 한계를 극복할 목적으로 만들어졌다.\n● DTD(Document Type Definition)\n문서 타입 정의(DTD)는 XML 문서의 구조 및 해당 문서에서 사용할 수 있는 적법한 요소와 속성을 정의한다.\n● Decorator\n함수를 받아 명령을 추가한 뒤 이를 다시 함수의 형태로 반환하는 함수이다. 반복을 줄이고 메소드나 함수의 책임을 확장\n할 수 있으며 재사용이 가능하게 해준다. 파이썬에서 @로 시작하는 구문으로 표시한다.\n● 공개 키 인증서(Public Key Certificate)\n공개키의 소유권을 증명하는데 사용되는 전자 문서이다. 키에대한 정보, 소유자의 신원에 대한 정보, 발급자의 디지털\n서명이 포함되어 있다.\n● 솔트(salt)\n솔트는 해싱 처리 과정 중 각 패스워드에 추가되는 랜덤으로 생성된 유일한 문자열을 의미한다.",
      "unsafe_codes": [],
      "safe_codes": [],
      "recommendations": []
    }
  ]
}