# security/vulnerability.py
"""
Vulnerability checking module - 통합 버전
기존 VulnerabilityChecker + Enhanced 기능 통합
"""
import re
import requests
from typing import List, Dict, Optional, Set
from config import vulnerability_config
from core.models import VulnerabilityInfo
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

class VulnerabilityChecker:
    """OSV API를 사용한 향상된 취약점 검사"""
    
    def __init__(self):
        self.config = vulnerability_config
        self.checked_packages = {}  # 캐시
        self.api_call_count = 0
        self.api_errors = []
    
    def check_package(self, package_name: str, version: str) -> List[VulnerabilityInfo]:
        """패키지의 취약점 검사 (캐시 지원)"""
        if not version or not package_name:
            return []
        
        # 캐시 확인
        cache_key = f"{package_name}:{version}"
        if cache_key in self.checked_packages:
            return self.checked_packages[cache_key]
        
        # 버전 정규화
        clean_version = re.sub(r'[><=!~^]', '', version).strip()
        clean_version = re.sub(r'\.post\d+', '', clean_version)  # .post0 제거
        
        if not clean_version or not re.match(r'^\d+(\.\d+)*', clean_version):
            return []
        
        vulnerabilities = []
        
        try:
            payload = {
                "package": {"name": package_name, "ecosystem": "PyPI"},
                "version": clean_version
            }
            
            response = requests.post(
                self.config.OSV_API_URL, 
                json=payload, 
                timeout=self.config.TIMEOUT
            )
            
            self.api_call_count += 1
            
            if response.status_code != 200:
                self.api_errors.append({
                    'package': package_name,
                    'status_code': response.status_code
                })
                return []
            
            data = response.json()
            
            for vuln in data.get("vulns", []):
                vuln_info = VulnerabilityInfo(
                    id=vuln.get("id", "Unknown"),
                    summary=vuln.get("summary", vuln.get("details", "No description")),
                    severity=self._get_severity(vuln),
                    fixed_version=self._get_fixed_version(vuln, package_name),
                    published_date=vuln.get("published", "")
                )
                vulnerabilities.append(vuln_info)
            
        except requests.exceptions.Timeout:
            self.api_errors.append({
                'package': package_name,
                'error': 'Timeout'
            })
        except Exception as e:
            self.api_errors.append({
                'package': package_name,
                'error': str(e)
            })
        
        # 캐시 저장
        self.checked_packages[cache_key] = vulnerabilities
        
        return vulnerabilities
    
    def check_all_dependencies(self, packages: List[Dict], indirect_deps: List[Dict], 
                             max_workers: int = 5) -> Dict:
        """모든 패키지와 종속성의 취약점을 병렬로 검사"""
        
        all_packages_to_check = []
        
        # 직접 패키지
        for pkg in packages:
            if pkg.get("actual_version"):
                all_packages_to_check.append({
                    'name': pkg["install_name"],
                    'version': pkg["actual_version"],
                    'type': 'direct',
                    'original': pkg
                })
        
        # 간접 종속성
        for dep in indirect_deps:
            if dep.get("version") and dep["version"] != "unknown":
                all_packages_to_check.append({
                    'name': dep["name"],
                    'version': dep["version"],
                    'type': 'indirect',
                    'original': dep
                })
        
        print(f"🔍 총 {len(all_packages_to_check)}개 패키지 취약점 검사 시작...")
        
        # 병렬 처리
        results = {
            'direct_vulnerabilities': {},
            'indirect_vulnerabilities': {},
            'statistics': {
                'total_checked': len(all_packages_to_check),
                'total_vulnerabilities': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'api_calls': 0,
                'api_errors': 0
            }
        }
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # 작업 제출
            future_to_package = {}
            
            for pkg_info in all_packages_to_check:
                future = executor.submit(
                    self.check_package,
                    pkg_info['name'],
                    pkg_info['version']
                )
                future_to_package[future] = pkg_info
            
            # 결과 수집
            completed = 0
            for future in as_completed(future_to_package):
                completed += 1
                pkg_info = future_to_package[future]
                
                # 진행 상황 표시
                if completed % 10 == 0:
                    print(f"  ✓ {completed}/{len(all_packages_to_check)} 완료...")
                
                try:
                    vulns = future.result()
                    
                    if vulns:
                        vuln_data = {
                            'package': pkg_info['name'],
                            'version': pkg_info['version'],
                            'vulnerabilities': []
                        }
                        
                        for v in vulns:
                            vuln_dict = {
                                'id': v.id,
                                'summary': v.summary[:200] + "..." if len(v.summary) > 200 else v.summary,
                                'severity': v.severity,
                                'fixed_version': v.fixed_version
                            }
                            vuln_data['vulnerabilities'].append(vuln_dict)
                            
                            # 통계 업데이트
                            results['statistics']['total_vulnerabilities'] += 1
                            severity_key = v.severity.lower()
                            if severity_key in results['statistics']:
                                results['statistics'][severity_key] += 1
                        
                        # 결과 저장
                        if pkg_info['type'] == 'direct':
                            results['direct_vulnerabilities'][pkg_info['name']] = vuln_data
                            # 원본 패키지 객체에도 추가
                            pkg_info['original']['vulnerabilities'] = vuln_data['vulnerabilities']
                        else:
                            results['indirect_vulnerabilities'][pkg_info['name']] = vuln_data
                
                except Exception as e:
                    print(f"  ❌ {pkg_info['name']} 검사 실패: {e}")
        
        # API 통계 업데이트
        results['statistics']['api_calls'] = self.api_call_count
        results['statistics']['api_errors'] = len(self.api_errors)
        
        # 취약점 요약
        self._print_vulnerability_summary(results)
        
        return results
    
    def _get_severity(self, vuln_data: dict) -> str:
        """취약점 심각도 판단"""
        severity_data = vuln_data.get("severity", [])
        
        for sev in severity_data:
            if sev.get("type") == "CVSS_V3":
                try:
                    score = float(sev.get("score", 0))
                    if score >= 9.0: return "CRITICAL"
                    elif score >= 7.0: return "HIGH"
                    elif score >= 4.0: return "MEDIUM"
                    else: return "LOW"
                except:
                    continue
        
        # 키워드 기반 추정
        summary = vuln_data.get("summary", "").lower()
        details = vuln_data.get("details", "").lower()
        
        critical_keywords = ['remote code execution', 'rce', 'arbitrary code']
        high_keywords = ['sql injection', 'xss', 'authentication bypass']
        
        for keyword in critical_keywords:
            if keyword in summary or keyword in details:
                return "CRITICAL"
        
        for keyword in high_keywords:
            if keyword in summary or keyword in details:
                return "HIGH"
        
        return "MEDIUM"
    
    def _get_fixed_version(self, vuln_data: dict, package_name: str) -> Optional[str]:
        """수정된 버전 찾기"""
        for aff in vuln_data.get("affected", []):
            if aff.get("package", {}).get("name") == package_name:
                for r in aff.get("ranges", []):
                    for event in r.get("events", []):
                        if "fixed" in event:
                            return event["fixed"]
        return None
    
    def _print_vulnerability_summary(self, results: Dict):
        """취약점 요약 출력"""
        stats = results['statistics']
        
        print("\n" + "=" * 60)
        print("🛡️ 취약점 검사 완료")
        print("=" * 60)
        
        print(f"📊 검사 통계:")
        print(f"  • 검사한 패키지: {stats['total_checked']}개")
        print(f"  • API 호출: {stats['api_calls']}회")
        print(f"  • API 오류: {stats['api_errors']}건")
        
        if stats['total_vulnerabilities'] > 0:
            print(f"\n⚠️ 발견된 취약점: {stats['total_vulnerabilities']}개")
            print(f"  • 🔴 CRITICAL: {stats['critical']}개")
            print(f"  • 🟠 HIGH: {stats['high']}개")
            print(f"  • 🟡 MEDIUM: {stats['medium']}개")
            print(f"  • 🟢 LOW: {stats['low']}개")
            
            # 직접 패키지 취약점
            if results['direct_vulnerabilities']:
                print(f"\n📦 직접 패키지 취약점:")
                for pkg_name, data in results['direct_vulnerabilities'].items():
                    print(f"  • {pkg_name} ({data['version']}): {len(data['vulnerabilities'])}개")
                    for vuln in data['vulnerabilities'][:2]:  # 처음 2개만
                        print(f"    - {vuln['severity']}: {vuln['id']}")
            
            # 간접 종속성 취약점
            if results['indirect_vulnerabilities']:
                print(f"\n📎 간접 종속성 취약점:")
                indirect_count = len(results['indirect_vulnerabilities'])
                print(f"  {indirect_count}개 종속성에서 취약점 발견")
                
                # 심각도 높은 것 우선 표시
                critical_deps = [
                    (name, data) for name, data in results['indirect_vulnerabilities'].items()
                    if any(v['severity'] == 'CRITICAL' for v in data['vulnerabilities'])
                ]
                
                if critical_deps:
                    print(f"  🔴 CRITICAL 취약점이 있는 종속성:")
                    for name, data in critical_deps[:5]:
                        print(f"    • {name} ({data['version']})")
        else:
            print(f"\n✅ 알려진 취약점 없음")
    
    def generate_report(self, results: Dict) -> str:
        """취약점 보고서 생성"""
        report = []
        report.append("# 취약점 검사 보고서\n")
        report.append(f"검사 시간: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        stats = results['statistics']
        report.append("## 요약\n")
        report.append(f"- 검사한 패키지: {stats['total_checked']}개\n")
        report.append(f"- 발견된 취약점: {stats['total_vulnerabilities']}개\n")
        report.append(f"  - CRITICAL: {stats['critical']}개\n")
        report.append(f"  - HIGH: {stats['high']}개\n")
        report.append(f"  - MEDIUM: {stats['medium']}개\n")
        report.append(f"  - LOW: {stats['low']}개\n\n")
        
        if results['direct_vulnerabilities']:
            report.append("## 직접 패키지 취약점\n\n")
            for pkg_name, data in results['direct_vulnerabilities'].items():
                report.append(f"### {pkg_name} ({data['version']})\n")
                for vuln in data['vulnerabilities']:
                    report.append(f"- **{vuln['severity']}** - {vuln['id']}\n")
                    report.append(f"  - {vuln['summary']}\n")
                    if vuln['fixed_version']:
                        report.append(f"  - 수정 버전: {vuln['fixed_version']}\n")
                report.append("\n")
        
        if results['indirect_vulnerabilities']:
            report.append("## 간접 종속성 취약점\n\n")
            # 심각도별로 그룹화
            by_severity = {'CRITICAL': [], 'HIGH': [], 'MEDIUM': [], 'LOW': []}
            
            for pkg_name, data in results['indirect_vulnerabilities'].items():
                for vuln in data['vulnerabilities']:
                    by_severity[vuln['severity']].append({
                        'package': pkg_name,
                        'version': data['version'],
                        'vuln': vuln
                    })
            
            for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
                if by_severity[severity]:
                    report.append(f"### {severity}\n")
                    for item in by_severity[severity]:
                        report.append(f"- {item['package']} ({item['version']}): {item['vuln']['id']}\n")
                    report.append("\n")
        
        return ''.join(report)


# 기존 호환성 유지를 위한 함수들
def check_vulnerabilities(packages: List[dict], analyzer_result: dict) -> dict:
    """패키지 목록의 취약점 검사 (기존 호환성)"""
    checker = VulnerabilityChecker()
    total_vulnerabilities = 0
    
    for pkg in packages:
        if pkg.get("version") and pkg.get("status") == "✅ 버전 확인됨":
            vulns = checker.check_package(pkg["install_name"], pkg["version"])
            if vulns:
                pkg["vulnerabilities"] = [
                    {
                        "id": v.id,
                        "summary": v.summary[:100] + "..." if len(v.summary) > 100 else v.summary,
                        "severity": v.severity,
                        "fixed_version": v.fixed_version
                    }
                    for v in vulns
                ]
                pkg["status"] = f"⚠️ 취약점 {len(vulns)}개 발견"
                total_vulnerabilities += len(vulns)
    
    analyzer_result["summary"]["total_vulnerabilities"] = total_vulnerabilities
    analyzer_result["summary"]["vulnerable_packages"] = sum(1 for p in packages if p.get("vulnerabilities"))
    
    return analyzer_result


def check_vulnerabilities_enhanced(packages: List[dict], indirect_deps: List[dict], 
                                  analyzer_result: dict) -> dict:
    """향상된 패키지 취약점 검사"""
    checker = VulnerabilityChecker()
    
    # 모든 패키지와 종속성 검사
    vuln_results = checker.check_all_dependencies(packages, indirect_deps)
    
    # 분석 결과에 통합
    analyzer_result['vulnerability_scan'] = vuln_results
    analyzer_result['summary']['total_vulnerabilities'] = vuln_results['statistics']['total_vulnerabilities']
    analyzer_result['summary']['vulnerable_packages'] = (
        len(vuln_results['direct_vulnerabilities']) + 
        len(vuln_results['indirect_vulnerabilities'])
    )
    
    # 보고서 생성
    analyzer_result['vulnerability_report'] = checker.generate_report(vuln_results)
    
    return analyzer_result